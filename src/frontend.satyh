@require: base/option-ext
@require: gr
@import: ./backend
@import: ./base/matrix
@import: ./base/graphics
@import: ./base/rect
@import: ./base/point
@import: ./base/paddings

module NCSqFrontend : sig

type cell
type direction

% commands
val cd : context -> (cell list) list -> inline-boxes
val +cd : [(cell list) list] block-cmd
val \cd : [(cell list) list] inline-cmd

% cells
val empty : cell
val object : float * float * float * float ?-> math -> cell
val arrow : direction -> cell

% directions
val left : direction
val right : direction
val up : direction
val down : direction
val rd : int * int -> direction
val ru : int * int -> direction
val ld : int * int -> direction
val lu : int * int -> direction

end = struct

type direction = (|
  horiz : int;
  vert : int;
|)

let left = (|horiz = -1; vert = 0|)
let right = (|horiz = 1; vert = 0|)
let up = (|horiz = 0; vert = 1|)
let down = (|horiz = 0; vert = -1|)
let rd (nh, nv) = (|horiz = nh; vert = Int.neg nv|)
let ru (nh, nv) = (|horiz = nh; vert = nv|)
let ld (nh, nv) = (|horiz = Int.neg nh; vert = Int.neg nv|)
let lu (nh, nv) = (|horiz = Int.neg nh; vert = nv|)

type cell =
| Empty
| Object of (|
  paddings : float * float * float * float;
  label : inline-text;
|)
| Arrow of (|
  direction : direction;
|)

let is-object cell =
match cell with
| Object _ -> true
| _ -> false

let shift-y = 0.33

let empty = Empty

let object ?:pds-o m =
let pds = Option.from (let pd = 0.25 in (pd, pd, pd, pd)) pds-o in
let it = {${#m}} in
Object (|
  paddings = pds;
  label = it;
|)

let arrow dir =
Arrow (|
  direction = dir;
|)

let make-cell-raw ctx cell =
match cell with
| Empty -> NCSqCellRaw.empty cell
| Object obj -> (
  let fs = get-font-size ctx in
  let pds = Paddings.relative obj#paddings fs in
  let gr = draw-text (0pt, 0pt) (read-inline ctx obj#label) in
  let rc = Rect.of-rect (get-graphics-bbox gr) in
  let c0 = Rect.center rc in
  let dy = fs *' 0.33 in
  let nc = Point.(neg (shift-y (Length.neg dy) c0)) in
  NCSqCellRaw.const cell Rect.(
    rc
    |> shift nc
    |> pad pds
  ) GraphicsList.(shift nc [gr])
)
| Arrow arr -> (
  let fs = get-font-size ctx in
  let tail = fs *' 0.8 in
  let head = fs *' 1.0 in
  let is-source c = is-object (NCSqCellRaw.data c) in
  let is-target = is-source in
  let dir = arr#direction in
  let ih = Interval.of-interval (
    if dir#horiz == 0 then (0pt, 0pt)
    else if dir#horiz < 0 then Length.((neg head, tail))
    else Length.((neg tail, head))
  ) in
  let iv = Interval.of-interval (
    if dir#vert == 0 then (0pt, 0pt)
    else if dir#vert < 0 then Length.((neg head, tail))
    else Length.((neg tail, head))
  ) in
  let draw from to = (
    Gr.arrow (fs *' 0.05) (get-text-color ctx) (fs *' 0.5) (fs *' 0.43) (fs *' 0.167)
    (Point.to-point from) (Point.to-point to)
  ) in
  NCSqCellRaw.edge (|
    data = cell;
    is-source = is-source;
    is-target = is-target;
    direction = arr#direction;
    bbox = Rect.of-intervals (|horiz = ih; vert = iv|);
    draw = draw;
  |)
)

let cd ctx cell-ll0 =
let cell-ll = List.reverse cell-ll0 in
let cell-raw-ll = List.(map (map (make-cell-raw ctx)) cell-ll) in
let c-mx = Matrix.of-list-of-rows (make-cell-raw ctx empty) cell-raw-ll in
let gr-l = NCSqBackend.draw-cellss-auto c-mx in
let rc = GraphicsList.bbox gr-l in
let ih = Rect.interval-h rc in
let iv = Rect.interval-v rc in
let w = Interval.width ih in
let yc = Interval.center iv in
let fs = get-font-size ctx in
let ym = yc -' fs *' shift-y in
let h = Interval.right iv -' ym in
let d = ym -' Interval.left iv in
let p0 = Point.of-point (Interval.left ih, ym) in
inline-graphics w h d
(fun p -> GraphicsList.shift Point.(of-point p - p0) gr-l)

let-block ctx +cd cell-ll =
line-break true true ctx (inline-fil ++ cd ctx cell-ll ++ inline-fil)

let-inline ctx \cd cell-ll =
inline-fil ++ embed-block-breakable ctx (read-block ctx '<+cd(cell-ll);>)

end
