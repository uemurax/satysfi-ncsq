@require: base/option-ext
@require: gr
@import: ./backend
@import: ./base/matrix
@import: ./base/graphics
@import: ./base/rect
@import: ./base/point
@import: ./base/paddings
@import: ./arrows

module NCSqFrontend : sig

type cell
type direction

% commands
val cd : context -> (cell list) list -> inline-boxes
val +cd : [(cell list) list] block-cmd
val \cd : [(cell list) list] inline-cmd

% cells
val empty : cell
val object : float * float * float * float ?-> math -> cell
val arrow : math ?-> math ?-> NCSqArrowStyle.t ?-> direction -> cell

% directions
val left : direction
val right : direction
val up : direction
val down : direction
val rd : int * int -> direction
val ru : int * int -> direction
val ld : int * int -> direction
val lu : int * int -> direction

% arrow styles
val solid : NCSqArrowStyle.t
val dashed : NCSqArrowStyle.t
val equal : NCSqArrowStyle.t

end = struct

type direction = (|
  horiz : int;
  vert : int;
|)

let left = (|horiz = -1; vert = 0|)
let right = (|horiz = 1; vert = 0|)
let up = (|horiz = 0; vert = 1|)
let down = (|horiz = 0; vert = -1|)
let rd (nh, nv) = (|horiz = nh; vert = Int.neg nv|)
let ru (nh, nv) = (|horiz = nh; vert = nv|)
let ld (nh, nv) = (|horiz = Int.neg nh; vert = Int.neg nv|)
let lu (nh, nv) = (|horiz = Int.neg nh; vert = nv|)

let solid = NCSqArrowStyle.solid
let dashed = NCSqArrowStyle.dashed
let equal = NCSqArrowStyle.equal

type arrow = (|
  direction : direction;
  style : NCSqArrowStyle.t;
  left-label-o : inline-text option;
  right-label-o : inline-text option;
|)

type cell =
| Empty
| Object of (|
  paddings : float * float * float * float;
  label : inline-text;
|)
| Arrow of arrow

let is-object cell =
match cell with
| Object _ -> true
| _ -> false

let shift-y = 0.33

let empty = Empty

let object ?:pds-o m =
let pds = Option.from (let pd = 0.25 in (pd, pd, pd, pd)) pds-o in
let it = {${#m}} in
Object (|
  paddings = pds;
  label = it;
|)

let arrow ?:ml-o ?:mr-o ?:style-o dir =
let m2it m = {${#m}} in
Arrow (|
  direction = dir;
  style = Option.from solid style-o;
  left-label-o = Option.map m2it ml-o;
  right-label-o = Option.map m2it mr-o;
|)

let label-ctx ctx = ctx |> set-font-size (get-font-size ctx *' 0.75)

module ArrowRaw : sig

type t

val bbox : t -> Rect.t
val draw : Point.t -> Point.t -> t -> graphics list

val of-arrow : context -> arrow -> t

end = struct

type rect = Rect.t
type point = Point.t

type t = (|
  bbox : rect;
  draw : point -> point -> graphics list;
|)

let bbox arr = arr#bbox
let draw from to arr = arr#draw from to

let locate-label a rc =
let w = Rect.width rc in
let h = Rect.height rc in
let cs = Float.cos a in
let sn = Float.sin a in
(w *' Float.abs cs +' h *' Float.abs sn) *' 0.5

let of-arrow ctx arr =
let fs = get-font-size ctx in
let style = NCSqArrowStyle.destruct arr#style ctx in
let gr-o = Option.map (fun it -> draw-text (0pt, 0pt) (read-inline (label-ctx ctx) it)) in
let grl-o = gr-o arr#left-label-o in
let grr-o = gr-o arr#right-label-o in
let rc = Option.map-or Rect.zero (fun gr -> Rect.of-rect (get-graphics-bbox gr)) in
let rcl = rc grl-o in
let rcr = rc grr-o in
let tail = style#tail-padding in
let head = style#head-padding in
let body = style#body-length in
let (l, r) = Interval.to-interval style#body-itv in
let d0 = fs *' 0.25 in
let dl = d0 +' Length.neg l in
let dr = d0 +' r in
let dir = arr#direction in
let mk-bbox a = (
  let al = a +. Float.pi *. 0.5 in
  let ll = dl +' locate-label al rcl in
  let ll1 = locate-label a rcl in
  let ptl = Point.of-arg ll al in
  let ar = a -. Float.pi *. 0.5 in
  let lr = dr +' locate-label ar rcr in
  let lr1 = locate-label a rcr in
  let ptr = Point.of-arg lr ar in
  let l1 = Length.(max ll1 (max lr1 (body *' 0.5))) in
  let rc1 = Rect.(shift Point.(ptl - center rcl) rcl) in
  let rc2 = Rect.(shift Point.(ptr - center rcr) rcr) in
  let lt = l1 +' tail in
  let lh = l1 +' head in
  let rc3 = Rect.(of-points (Point.(neg (of-arg lt a))) (Point.of-arg lh a)) in
  Rect.(union rc1 (union rc2 rc3))
) in
let pi = Float.pi in
let pi2 = pi *. 0.5 in
let npi2 = Float.(neg pi2) in
let bbox = (
  if dir#horiz < 0 then (
    let rc1 = mk-bbox pi in
    if dir#vert < 0 then (
      Rect.union rc1 (mk-bbox npi2)
    ) else if dir#vert == 0 then (
      rc1
    ) else (
      Rect.union rc1 (mk-bbox pi2)
    )
  ) else if dir#horiz == 0 then (
    if dir#vert < 0 then (
      mk-bbox npi2
    ) else if dir#vert == 0 then (
      Rect.zero
    ) else (
      mk-bbox pi2
    )
  ) else (
    let rc1 = mk-bbox 0.0 in
    if dir#vert < 0 then (
      Rect.union rc1 (mk-bbox npi2)
    ) else if dir#vert == 0 then (
      rc1
    ) else (
      Rect.union rc1 (mk-bbox pi2)
    )
  )
) in
let draw from to = (
  let gr-l1 = style#draw from to in
  Point.(arg (to - from))
  |> Option.map-or gr-l1 (fun a -> (
    let grl d a gr-o = (
      gr-o
      |> Option.map-or [] (fun gr -> (
        let rc = Rect.of-rect (get-graphics-bbox gr) in
        let l = d +' locate-label a rc in
        let pt = Point.of-arg l a in
        let gr-1 = shift-graphics Point.(to-point (pt - Rect.center rc)) gr in
        [gr-1]
      ))
    ) in
    let grl-l = grl dl (a +. Float.pi *. 0.5) grl-o in
    let grr-l = grl dr (a -. Float.pi *. 0.5) grr-o in
    let gr-l2 = List.append grl-l grr-l in
    let dt = Point.of-arg tail a in
    let dh = Point.(neg (of-arg head a)) in
    let c = Point.(mid (from + dt) (to + dh)) in
    let gr-l3 = GraphicsList.shift c gr-l2 in
    List.append gr-l1 gr-l3
  ))
) in
(|
  bbox = bbox;
  draw = draw;
|)

end

let make-cell-raw ctx cell =
match cell with
| Empty -> NCSqCellRaw.empty cell
| Object obj -> (
  let fs = get-font-size ctx in
  let pds = Paddings.relative obj#paddings fs in
  let gr = draw-text (0pt, 0pt) (read-inline ctx obj#label) in
  let rc = Rect.of-rect (get-graphics-bbox gr) in
  let c0 = Rect.center rc in
  let dy = fs *' 0.33 in
  let nc = Point.(neg (shift-y (Length.neg dy) c0)) in
  NCSqCellRaw.const cell Rect.(
    rc
    |> shift nc
    |> pad pds
  ) GraphicsList.(shift nc [gr])
)
| Arrow arr -> (
  let arr1 = ArrowRaw.of-arrow ctx arr in
  let is-source c = is-object (NCSqCellRaw.data c) in
  let is-target = is-source in
  NCSqCellRaw.edge (|
    data = cell;
    is-source = is-source;
    is-target = is-target;
    direction = arr#direction;
    bbox = ArrowRaw.bbox arr1;
    draw = fun from to -> ArrowRaw.draw from to arr1;
  |)
)

let cd ctx cell-ll0 =
let cell-ll = List.reverse cell-ll0 in
let cell-raw-ll = List.(map (map (make-cell-raw ctx)) cell-ll) in
let c-mx = Matrix.of-list-of-rows (make-cell-raw ctx empty) cell-raw-ll in
let gr-l = NCSqBackend.draw-cellss-auto c-mx in
let rc = GraphicsList.bbox gr-l in
let ih = Rect.interval-h rc in
let iv = Rect.interval-v rc in
let w = Interval.width ih in
let yc = Interval.center iv in
let fs = get-font-size ctx in
let ym = yc -' fs *' shift-y in
let h = Interval.right iv -' ym in
let d = ym -' Interval.left iv in
let p0 = Point.of-point (Interval.left ih, ym) in
inline-graphics w h d
(fun p -> GraphicsList.shift Point.(of-point p - p0) gr-l)

let-block ctx +cd cell-ll =
line-break true true ctx (inline-fil ++ cd ctx cell-ll ++ inline-fil)

let-inline ctx \cd cell-ll =
inline-fil ++ embed-block-breakable ctx (read-block ctx '<+cd(cell-ll);>)

end
