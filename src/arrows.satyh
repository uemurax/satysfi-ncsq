@require: pervasives
@require: base/list-ext
@require: base/option-ext
@require: base/length
@require: base/float
@require: gr
@import: ./ncsq-util

module NCSqConst : sig

val line-width : float
val vee-min-width : float
val vee-ext : float
val hook-min-width : float
val hook-ext : float
val tri-min-width : float
val tri-ext : float
val pd-base : float

end = struct

let line-width = 0.042

let vee-min-width = 0.125
let vee-ext = 0.125
let hook-min-width = vee-min-width
let hook-ext = vee-ext *. 1.5
let tri-min-width = vee-min-width *. 0.7
let tri-ext = vee-ext *. 0.7

let pd-base = 0.67

end

module NCSqArrowBody : sig

type t

% Basic body styles
val none : t
val solid : t
% double solid lines =====
val solid-2 : t
val multi-solid : int -> t
val dashed : t
% double dashed lines = = =
val dashed-2 : t
val multi-dashed : int -> t

% Body transformers
% Adjoin |, e.g. `cross solid` looks like --+--
val cross : t -> t
% duplicate lines with spacing
val multiple : int -> float -> t -> t

val destruct : t -> context -> (|
  metadata : (|
    mid-left : length;
    mid-right : length;
    end-left : length;
    end-right : length;
    min-len : length;
  |);
  draw : (
    (|
      % metadata of tail
      depth : length -> length;
      padding : length;
    |) ->
    (|
      % metadata of head
      depth : length -> length;
      padding : length;
    |) ->
    point ->                    % from
    point ->                    % to
    graphics list
  );
|)

end = struct

type metadata = (|
  mid-left : length;
  mid-right : length;
  end-left : length;
  end-right : length;
  min-len : length;
|)

type tail-metadata = (|
  depth : length -> length;
  padding : length;
|)

type head-metadata = (|
  depth : length -> length;
  padding : length;
|)

type t = context -> (|
  metadata : metadata;
  draw : tail-metadata -> head-metadata -> point -> point -> graphics list;
|)

let destruct body = body

let none _ = (|
  metadata = (|
    mid-left = 0pt;
    mid-right = 0pt;
    end-left = 0pt;
    end-right = 0pt;
    min-len = 0pt;
  |);
  draw = fun _ _ _ _ -> [];
|)

let union body1 body2 ctx =
let b1 = body1 ctx in
let b2 = body2 ctx in
let m1 = b1#metadata in
let m2 = b2#metadata in
(|
  metadata = (|
    mid-left = Length.min m1#mid-left m2#mid-left;
    mid-right = Length.max m1#mid-right m2#mid-right;
    end-left = Length.min m1#end-left m2#end-left;
    end-right = Length.max m1#end-right m2#end-right;
    min-len = Length.max m1#min-len m2#min-len;
  |);
  draw = fun tail head from to -> (
    let gr-l1 = b1#draw tail head from to in
    let gr-l2 = b2#draw tail head from to in
    List.concat [gr-l1; gr-l2]
  );
|)

let shift p body ctx =
let b = body ctx in
let m = b#metadata in
(|
  metadata = (|
    m with
    mid-left = m#mid-left +' p;
    mid-right = m#mid-right +' p;
    end-left = m#end-left +' p;
    end-right = m#end-right +' p
  |);
  draw = fun tail head from to -> (
    match NCSqUtil.angle from to with
    | None -> []
    | Some (dx, dy) -> (
      let (x0, y0) = from in
      let (x1, y1) = to in
      let (s, t) = (p *' dy, Length.neg (p *' dx)) in
      let z = (x0 +' s, y0 +' t) in
      let w = (x1 +' s, y1 +' t) in
      let tail1 = (|
        tail with
        depth = fun q -> tail#depth (q +' p)
      |) in
      let head1 = (|
        head with
        depth = fun q -> head#depth (q +' p)
      |) in
      b#draw tail1 head1 z w
    )
  );
|)

let multiple n pd body ctx =
let b = body ctx in
let m = b#metadata in
let left = Length.(min m#end-left m#mid-left) in
let right = Length.(max m#end-right m#mid-right) in
let w = Length.abs (right -' left) in
let d = w +' get-font-size ctx *' pd in
let-rec aux acc p n = (
  if n <= 0 then acc
  else (
    let b1 = shift p body in
    let p1 = p -' d in
    let acc1 = union b1 acc in
    aux acc1 p1 (n - 1)
  )
) in
aux none (d *' Float.(0.5 *. of-int (n - 1))) n ctx

let line-end-points from to t0 h0 =
NCSqUtil.angle from to
|> Option.map (fun (dx, dy) -> (
  let (x0, y0) = from in
  let (x1, y1) = to in
  let a0 = x0 +' t0 *' dx in
  let b0 = y0 +' t0 *' dy in
  let a1 = x1 -' h0 *' dx in
  let b1 = y1 -' h0 *' dy in
  ((a0, b0), (a1, b1))
))

let line strokef =
(|
  metadata = (|
    end-left = 0pt;
    end-right = 0pt;
    mid-left = 0pt;
    mid-right = 0pt;
    min-len = 0pt;
  |);
  draw = fun tail head from to -> (
    let t = tail#depth 0pt in
    let h = head#depth 0pt in
    match line-end-points from to t h with
    | None -> []
    | Some (z0, z1) -> (
      let curve = Gr.line z0 z1 in
      [strokef t h curve]
    )
  );
|)

let solid ctx =
let fs = get-font-size ctx in
let lw = fs *' NCSqConst.line-width in
let color = get-text-color ctx in
line (fun _ _ -> stroke lw color)

let spacing = NCSqConst.line-width *. 4.0

let multi-solid n = multiple n spacing solid

let solid-2 ctx = multi-solid 2 ctx

let dashed ctx =
let fs = get-font-size ctx in
let lw = fs *' NCSqConst.line-width in
let color = get-text-color ctx in
let d1 = fs *' 0.25 in
let d2 = d1 in
line (fun t _ -> dashed-stroke lw (d1, d2, t) color)

let multi-dashed n = multiple n spacing dashed

let dashed-2 ctx = multi-dashed 2 ctx

let cross body ctx =
let b = body ctx in
let bm = b#metadata in
let fs = get-font-size ctx in
let w0 = fs *' NCSqConst.vee-min-width in
let w1 = Length.(max (neg bm#mid-left) bm#mid-right) in
let w2 = Length.max w0 w1 in
let w3 = w2 +' fs *' NCSqConst.vee-ext in
let lw = fs *' NCSqConst.line-width in
let color = get-text-color ctx in
(|
  metadata = (|
    bm with
    mid-left = Length.neg w3;
    mid-right = w3;
    min-len = Length.max bm#min-len lw;
  |);
  draw = fun tail head from to -> (
    let gr-l1 = b#draw tail head from to in
    let gr-l2 = (
      match NCSqUtil.angle from to with
      | None -> []
      | Some (dx, dy) -> (
        let (x0, y0) = from in
        let (x1, y1) = to in
        let tp = tail#padding in
        let hp = head#padding in
        let (a0, b0) = (x0 +' tp *' dx, y0 +' tp *' dy) in
        let (a1, b1) = (x1 -' hp *' dx, y1 -' hp *' dy) in
        let (a2, b2) = ((a0 +' a1) *' 0.5, (b0 +' b1) *' 0.5) in
        let (wx, wy) = (w3 *' dy, w3 *' dx) in
        let c1 = (a2 -' wx, b2 +' wy) in
        let c2 = (a2 +' wx, b2 -' wy) in
        let gr = stroke lw color (Gr.line c1 c2) in
        [gr]
      )
    ) in
    List.concat [gr-l1; gr-l2]
  );
|)

end

module NCSqArrowHead : sig

type t

% Basic head styles
val none : t
% ->
val vee : t
% ->>
val vee-2 : t
val multi-vee : int -> t
% -|>
val triangle : t
% __\
val harpoon-l : t
% ‾‾/
val harpoon-r : t

% Head transformers
val shift : bool -> float -> t -> t
val union : t -> t -> t
% duplicate with shift
val duplicate : bool -> int -> float -> t -> t

val destruct : t -> context -> (
  (|
    % metadata of body
    mid-left : length;
    mid-right : length;
    end-left : length;
    end-right : length;
    min-len : length;
  |) ->
  (|
    metadata : (|
      padding : length;
      depth : length -> length;
    |);
    draw : float * float -> graphics list;
  |)
)

end = struct

type body-metadata = (|
  mid-left : length;
  mid-right : length;
  end-left : length;
  end-right : length;
  min-len : length;
|)

type metadata = (|
  padding : length;
  depth : length -> length;
|)

type t = context -> body-metadata -> (|
  metadata: metadata;
  draw : float * float -> graphics list;
|)

let destruct head = head

let none ctx _ =
let pd = get-font-size ctx *' NCSqConst.pd-base in
(|
  metadata = (|
    padding = pd;
    depth = fun _ -> 0pt;
  |);
  draw = fun _ -> [];
|)

let shift keep-depth p head ctx body =
let h = head ctx body in
let m = h#metadata in
let pd = get-font-size ctx *' p in
let np = Length.neg pd in
(|
  metadata = (|
    padding = m#padding +' pd;
    depth = (
      if keep-depth then m#depth
      else fun q -> m#depth q +' pd
    );
  |);
  draw = fun (dx, dy) -> (
    h#draw (dx, dy)
    |> List.map (shift-graphics (np *' dx, np *' dy))
  );
|)

let union head1 head2 ctx body =
let h1 = head1 ctx body in
let h2 = head2 ctx body in
let m1 = h1#metadata in
let m2 = h2#metadata in
(|
  metadata = (|
    padding = Length.(max m1#padding m2#padding);
    depth = fun p -> Length.(max (m1#depth p) (m2#depth p));
  |);
  draw = fun (dx, dy) -> (
    let gr-l1 = h1#draw (dx, dy) in
    let gr-l2 = h2#draw (dx, dy) in
    List.concat [gr-l1; gr-l2]
  );
|)

let-rec duplicate keep-depth n p head =
if n <= 0 then none
else (
  let h1 = duplicate keep-depth (n - 1) p head in
  let h2 = shift keep-depth p h1 in
  union head h2
)

let vee ctx body =
let w0 = get-font-size ctx in
let color = get-text-color ctx in
let d0 = w0 *' NCSqConst.vee-min-width in
let d1 = Length.(max (max (abs body#end-left) (abs body#end-right)) d0) in
let d2 = w0 *' NCSqConst.vee-ext in
let d = d1 +' d2 in
let nd = Length.neg d in
let curve = Gr.poly-line (nd, d) [(0pt, 0pt); (nd, nd)] in
let lw = w0 *' NCSqConst.line-width in
(|
  metadata = (|
    padding = w0 *' NCSqConst.pd-base +' d;
    depth = Length.abs;
  |);
  draw = fun (dx, dy) -> (
    let curve1 = linear-transform-path dx (Float.neg dy) dy dx curve in
    [stroke lw color curve1]
  );
|)

let vee-shift = NCSqConst.vee-min-width *. 1.5

let multi-vee n = duplicate true n vee-shift vee

let vee-2 ctx body = multi-vee 2 ctx body

let sqrt3 = Float.sqrt 3.0

let triangle ctx body =
let fs = get-font-size ctx in
let color = get-text-color ctx in
let d0 = fs *' NCSqConst.tri-min-width in
let d1 = Length.(max (max (abs body#end-left) (abs body#end-right)) d0) in
let d2 = fs *' NCSqConst.tri-ext in
let d = d1 +' d2 in
let h = d *' sqrt3 in
let nh = Length.neg h in
let curve = Gr.polygon (0pt, 0pt) [(nh, d); (nh, Length.neg d)] in
let lw = fs *' NCSqConst.line-width in
(|
  metadata = (|
    padding = fs *' NCSqConst.pd-base +' h;
    depth = fun _ -> h;
  |);
  draw = fun (dx, dy) -> (
    let curve1 = linear-transform-path dx (Float.neg dy) dy dx curve in
    [stroke lw color curve1]
  );
|)

let harpoon-l-1 ctx body =
let fs = get-font-size ctx in
let r = body#end-right in
let l = body#end-left in
let d0 = fs *' NCSqConst.vee-min-width in
let d1 = Length.(max (r -' l) d0) in
let d2 = fs *' NCSqConst.vee-ext in
let d = d1 +' d2 in
let nd = Length.neg d in
(|
  metadata = (|
    padding = fs *' NCSqConst.pd-base +' d;
    depth = fun p -> r -' p;
  |);
  curve = fun (dx, dy) -> (
    Gr.line (0pt, 0pt) (nd, d)
    |> shift-path (0pt, Length.neg r)
    |> linear-transform-path dx (Float.neg dy) dy dx
  );
|)

let harpoon-l ctx body =
let h1 = harpoon-l-1 ctx body in
let color = get-text-color ctx in
let lw = get-font-size ctx *' NCSqConst.line-width in
(|
  metadata = h1#metadata;
  draw = fun (dx, dy) -> (
    let curve = h1#curve (dx, dy) in
    [stroke lw color curve]
  );
|)

let harpoon-r ctx body =
let h1 = harpoon-l-1 ctx (|
  body with
  end-left = Length.neg body#end-right;
  end-right = Length.neg body#end-left;
|) in
let m1 = h1#metadata in
let color = get-text-color ctx in
let lw = get-font-size ctx *' NCSqConst.line-width in
(|
  metadata = (|
    m1 with
    depth = fun p -> m1#depth (Length.neg p);
  |);
  draw = fun (dx, dy) -> (
    let curve = (
      let (a, b, c, d) = NCSqUtil.mirror (dx, dy) in
      h1#curve (dx, dy)
      |> linear-transform-path a b c d
    ) in
    [stroke lw color curve]
  );
|)

end

module NCSqArrowTail : sig

type t

% Basic tail styles
val none : t
% >-
val vee : t
% (_
val hook-l : t
% ((_
val hook-l-2 : t
val multi-hook-l : int -> t
% (‾
val hook-r : t
% ((‾
val hook-r-2 : t
val multi-hook-r : int -> t
% |-
val vdash : t

% Tail transformers
val shift : bool -> float -> t -> t
val union : t -> t -> t
% duplicate with shift
val duplicate : bool -> int -> float -> t -> t

val destruct : t -> context -> (
  (|
    % metadata of body
    mid-left : length;
    mid-right : length;
    end-left : length;
    end-right : length;
    min-len : length;
  |) ->
  (|
    metadata : (|
      padding : length;
      depth : length -> length;
    |);
    draw : float * float -> graphics list;
  |)
)

end = struct

type body-metadata = (|
  mid-left : length;
  mid-right : length;
  end-left : length;
  end-right : length;
  min-len : length;
|)

type metadata = (|
  padding : length;
  depth : length -> length;
|)

type t = context -> body-metadata -> (|
  metadata : metadata;
  draw : float * float -> graphics list;
|)

let destruct tail = tail

let none ctx _ =
let pd = get-font-size ctx *' 0.67 in
(|
  metadata = (|
    padding = pd;
    depth = fun _ -> 0pt;
  |);
  draw = fun _ -> [];
|)

let vee ctx body =
let w0 = get-font-size ctx in
let color = get-text-color ctx in
let d0 = w0 *' NCSqConst.vee-min-width in
let d1 = Length.(max (max (abs body#end-left) (abs body#end-right)) d0) in
let d2 = w0 *' NCSqConst.vee-ext in
let d = d1 +' d2 in
let curve = Gr.poly-line (0pt, d) [(d, 0pt); (0pt, Length.neg d)] in
let lw = w0 *' NCSqConst.line-width in
(|
  metadata = (|
    padding = w0 *' NCSqConst.pd-base +' d;
    depth = fun x -> d -' (Length.abs x);
  |);
  draw = fun (dx, dy) -> (
    let curve1 = linear-transform-path dx (Float.neg dy) dy dx curve in
    [stroke lw color curve1]
  );
|)

% curve from (r, -r) to (r, r) via (0, 0)
% approximately a half circle
let hook-path r =
let t = r *' 0.55228 in             % cf. Gr.circle
let rt = r -' t in
let nr = Length.neg r in
start-path (r, nr)
|> bezier-to (rt, nr) (0pt, Length.neg t) (0pt, 0pt)
|> bezier-to (0pt, t) (rt, r) (r, r)
|> terminate-path

let hook-depth r y =
let yy = y /' 1pt in
let rr = r /' 1pt in
let s = yy /. rr in
let xx = rr *. (1.0 -. Float.sqrt(1.0 -. s *. s)) in
1pt *' xx

let hook-l-1 ctx body =
let fs = get-font-size ctx in
let w0 = fs *' NCSqConst.hook-min-width in
let w1 = body#end-right -' body#end-left in
let w2 = fs *' NCSqConst.hook-ext in
let w = (Length.(max w0 w1) +' w2) in
let r = w *' 0.5 in
let path = hook-path r in
let curve = hook-path r in
let centre = body#end-right -' r in
(|
  metadata = (|
    padding = fs *' NCSqConst.pd-base +' r;
    depth = fun y0 -> (
      let y = y0 -' centre in
      if Length.(y > r) then r
      else if Length.(y >= neg r) then hook-depth r y
      else r
    );
  |);
  curve = fun (dx, dy) -> (
    curve
    |> shift-path (0pt, 0pt -' centre)
    |> linear-transform-path dx (Float.neg dy) dy dx
  );
|)

let hook-l ctx body =
let h1 = hook-l-1 ctx body in
let lw = get-font-size ctx *' NCSqConst.line-width in
let color = get-text-color ctx in
(|
  metadata = h1#metadata;
  draw = fun (dx, dy) -> (
    let cv = h1#curve (dx, dy) in
    [stroke lw color cv]
  );
|)

let hook-r ctx body =
let h1 = hook-l-1 ctx (|
  body with
  end-left = Length.neg body#end-right;
  end-right = Length.neg body#end-left;
|) in
let lw = get-font-size ctx *' NCSqConst.line-width in
let color = get-text-color ctx in
(|
  metadata = (|
    h1#metadata with
    depth = fun y -> (h1#metadata#depth (Length.neg y));
  |);
  draw = fun (dx, dy) -> (
    let (a, b, c, d) = NCSqUtil.mirror (dx, dy) in
    let cv = (
      h1#curve (dx, dy)
      |> linear-transform-path a b c d
    ) in
    [stroke lw color cv]
  );
|)

let shift keep-depth p tail ctx body =
let t = tail ctx body in
let m = t#metadata in
let pd = get-font-size ctx *' p in
(|
  metadata = (|
    padding = m#padding +' pd;
    depth = (
      if keep-depth then m#depth
      else fun q -> m#depth q +' pd
    );
  |);
  draw = fun (dx, dy) -> (
    t#draw (dx, dy)
    |> List.map (shift-graphics (pd *' dx, pd *' dy))
  );
|)

let union tail1 tail2 ctx body =
let t1 = tail1 ctx body in
let t2 = tail2 ctx body in
let m1 = t1#metadata in
let m2 = t2#metadata in
(|
  metadata = (|
    padding = Length.(max m1#padding m2#padding);
    depth = fun p -> Length.(max (m1#depth p) (m2#depth p));
  |);
  draw = fun (dx, dy) -> (
    let gr-l1 = t1#draw (dx, dy) in
    let gr-l2 = t2#draw (dx, dy) in
    List.concat [gr-l1; gr-l2]
  );
|)

let-rec duplicate keep-depth n p tail =
if n <= 0 then none
else (
  let t1 = duplicate keep-depth (n - 1) p tail in
  let t2 = shift keep-depth p t1 in
  union tail t2
)

let hook-shift = NCSqConst.hook-min-width *. 1.5

let multi-hook-l n = duplicate true n hook-shift hook-l

let hook-l-2 ctx body = multi-hook-l 2 ctx body

let multi-hook-r n = duplicate true n hook-shift hook-r

let hook-r-2 ctx body = multi-hook-r 2 ctx body

let vdash ctx body =
let fs = get-font-size ctx in
let color = get-text-color ctx in
let d0 = fs *' NCSqConst.vee-min-width in
let d1 = Length.(max (max (abs body#end-left) (abs body#end-right)) d0) in
let d2 = fs *' NCSqConst.vee-ext in
let d = d1 +' d2 in
let curve = Gr.line (0pt, d) (0pt, Length.neg d) in
let lw = fs *' NCSqConst.line-width in
(|
  metadata = (|
    padding = fs *' NCSqConst.pd-base;
    depth = fun _ -> 0pt;
  |);
  draw = fun (dx, dy) -> (
    let curve1 = linear-transform-path dx (Float.neg dy) dy dx curve in
    [stroke lw color curve1]
  );
|)

end

module NCSqArrowStyle : sig

type t

% ----->
val solid : t
% - - ->
val dashed : t
% =====
val equal : t
% =====>
val solid-2 : t
% >---->
val tail : t
% ---->>
val two-heads : t
% (____>
val hook-l : t
% (‾‾‾‾>
val hook-r : t
% ----|>
val triangle : t
% |---->
val mapsto : t

val harpoon-l : t
val harpoon-r : t

val of-bth : NCSqArrowBody.t -> NCSqArrowTail.t -> NCSqArrowHead.t -> t

val destruct : t -> context -> (|
  body-left : length;
  body-right : length;
  body-length : length;
  tail-padding : length;
  head-padding : length;
  draw : point -> point -> graphics list
|)

end = struct

type body = NCSqArrowBody.t
type tail = NCSqArrowTail.t
type head = NCSqArrowHead.t

type t = body * tail * head

let of-bth body tail head = (body, tail, head)

let solid = of-bth NCSqArrowBody.solid NCSqArrowTail.none NCSqArrowHead.vee
let dashed = of-bth NCSqArrowBody.dashed NCSqArrowTail.none NCSqArrowHead.vee
let equal = of-bth NCSqArrowBody.solid-2 NCSqArrowTail.none NCSqArrowHead.none
let solid-2 = of-bth NCSqArrowBody.solid-2 NCSqArrowTail.none NCSqArrowHead.vee
let tail = of-bth NCSqArrowBody.solid NCSqArrowTail.vee NCSqArrowHead.vee
let two-heads = of-bth NCSqArrowBody.solid NCSqArrowTail.none NCSqArrowHead.vee-2
let hook-l = of-bth NCSqArrowBody.solid NCSqArrowTail.hook-l NCSqArrowHead.vee
let hook-r = of-bth NCSqArrowBody.solid NCSqArrowTail.hook-r NCSqArrowHead.vee
let triangle = of-bth NCSqArrowBody.solid NCSqArrowTail.none NCSqArrowHead.triangle
let mapsto = of-bth NCSqArrowBody.solid NCSqArrowTail.vdash NCSqArrowHead.vee
let harpoon-l = of-bth NCSqArrowBody.solid NCSqArrowTail.none NCSqArrowHead.harpoon-l
let harpoon-r = of-bth NCSqArrowBody.solid NCSqArrowTail.none NCSqArrowHead.harpoon-r

let destruct (body, tail, head) ctx =
let b = NCSqArrowBody.destruct body ctx in
let bm = b#metadata in
let t = NCSqArrowTail.destruct tail ctx bm in
let h = NCSqArrowHead.destruct head ctx bm in
(|
  body-left = bm#mid-left;
  body-right = bm#mid-right;
  body-length = bm#min-len;
  tail-padding = t#metadata#padding;
  head-padding = h#metadata#padding;
  draw = fun from to -> (
    match NCSqUtil.angle from to with
    | None -> []
    | Some a -> (
      let grs-tail = List.map (shift-graphics from) (t#draw a) in
      let grs-body = b#draw t#metadata h#metadata from to in
      let grs-head = List.map (shift-graphics to) (h#draw a) in
      List.concat [grs-tail; grs-body; grs-head]
    )
  );
|)

end
