@require: pervasives
@require: base/list-ext
@require: base/option-ext
@require: base/length
@require: base/float
@require: gr
@import: ./ncsq-util

module NCSqConst : sig

val line-width : float
val vee-min-width : float
val vee-ext : float
val hook-min-width : float
val hook-ext : float
val pd-base : float

end = struct

let line-width = 0.042

let vee-min-width = 0.125
let vee-ext = 0.125
let hook-min-width = vee-min-width
let hook-ext = vee-ext *. 1.5

let pd-base = 0.67

end

module NCSqArrowBody : sig

type t

val destruct : t -> context -> (|
  metadata : (|
    mid-left : length;
    mid-right : length;
    end-left : length;
    end-right : length;
    min-len : length;
  |);
  draw : (
    (|
      % metadata of tail
      depth : length -> length;
      padding : length;
    |) ->
    (|
      % metadata of head
      depth : length -> length;
      padding : length;
    |) ->
    point ->                    % from
    point ->                    % to
    graphics list
  );
|)

val none : t
val solid : t
% double solid lines =====
val solid-2 : t
val multi-solid : int -> t
val dashed : t
% double dashed lines = = =
val dashed-2 : t
val multi-dashed : int -> t

% Decorators
% --+--
val cross : t -> t

end = struct

type metadata = (|
  mid-left : length;
  mid-right : length;
  end-left : length;
  end-right : length;
  min-len : length;
|)

type tail-metadata = (|
  depth : length -> length;
  padding : length;
|)

type head-metadata = (|
  depth : length -> length;
  padding : length;
|)

type t = context -> (|
  metadata : metadata;
  draw : tail-metadata -> head-metadata -> point -> point -> graphics list;
|)

let destruct body = body

let none _ = (|
  metadata = (|
    mid-left = 0pt;
    mid-right = 0pt;
    end-left = 0pt;
    end-right = 0pt;
    min-len = 0pt;
  |);
  draw = fun _ _ _ _ -> [];
|)

let shift ((x0, y0), (x1, y1)) p =
NCSqUtil.angle (x0, y0) (x1, y1)
|> Option.map (fun (dx, dy) -> (
  let dx0 = p *' dx in
  let dy0 = p *' dy in
  ((x0 +' dy0, y0 -' dx0), (x1 +' dy0, y1 -' dx0))
))

let of-lines lf-l0 ctx =
let fs = get-font-size ctx in
let lf-l = List.map (fun (x, f) -> (fs *' x, f ctx)) lf-l0 in
let left = List.fold-right (fun (pos, _) l -> Length.(min l pos)) 0pt lf-l in
let right = List.fold-right (fun (pos, _) r -> Length.(max r pos)) 0pt lf-l in
let-rec aux gr-ll lf-l tail head from to = (
  match lf-l with
  | [] -> List.concat gr-ll
  | (pos, lf) :: lf-l1 -> (
    let gr-ll1 = (
      match shift (from, to) pos with
      | None -> gr-ll
      | Some (z, w) -> (
        let gr-l = lf z w (tail#depth pos) (head#depth pos) in
        gr-l :: gr-ll
      )
    ) in
    aux gr-ll1 lf-l1 tail head from to
  )
) in
(|
  metadata = (|
    mid-left = left;
    mid-right = right;
    end-left = left;
    end-right = right;
    min-len = 0pt;
  |);
  draw = aux [] lf-l;
|)

let line-end-points from to t0 h0 =
NCSqUtil.angle from to
|> Option.map (fun (dx, dy) -> (
  let (x0, y0) = from in
  let (x1, y1) = to in
  let a0 = x0 +' t0 *' dx in
  let b0 = y0 +' t0 *' dy in
  let a1 = x1 -' h0 *' dx in
  let b1 = y1 -' h0 *' dy in
  ((a0, b0), (a1, b1))
))

let line ctx =
let fs = get-font-size ctx in
let c = get-text-color ctx in
fun x y t h -> (
  match line-end-points x y t h with
  | None -> []
  | Some (a, b) -> (
    [stroke (fs *' NCSqConst.line-width) c (Gr.line a b)]
  )
)

let multi-lines n lf =
let p = NCSqConst.line-width *. 2.0 in
let q = p *. 2.0 in
let b = Float.(neg (p *. of-int (n - 1))) in
let-rec aux ls x m = (
  if m <= 0 then ls
  else aux ((x, lf) :: ls) (x +. q) (m - 1)
) in
of-lines (aux [] b n)

let multi-solid n = multi-lines n line

let solid ctx = multi-solid 1 ctx
let solid-2 ctx = multi-solid 2 ctx

let dashed-line ctx =
let fs = get-font-size ctx in
let d1 = fs *' 0.25 in
let d2 = d1 in
let c = get-text-color ctx in
fun x y t h -> (
  match line-end-points x y t h with
  | None -> []
  | Some (a, b) -> (
    let w = fs *' NCSqConst.line-width in
    let dash = (d1, d2, t) in
    [dashed-stroke w dash c (Gr.line a b)]
  )
)

let multi-dashed n = multi-lines n dashed-line

let dashed ctx = multi-dashed 1 ctx
let dashed-2 ctx = multi-dashed 2 ctx

let cross body ctx =
let b = body ctx in
let bm = b#metadata in
let fs = get-font-size ctx in
let w0 = fs *' NCSqConst.vee-min-width in
let w1 = Length.(max (neg bm#mid-left) bm#mid-right) in
let w2 = Length.max w0 w1 in
let w3 = w2 +' fs *' NCSqConst.vee-ext in
let lw = fs *' NCSqConst.line-width in
let color = get-text-color ctx in
(|
  metadata = (|
    bm with
    mid-left = Length.neg w3;
    mid-right = w3;
    min-len = Length.max bm#min-len lw;
  |);
  draw = fun tail head from to -> (
    let gr-l1 = b#draw tail head from to in
    let gr-l2 = (
      match NCSqUtil.angle from to with
      | None -> []
      | Some (dx, dy) -> (
        let (x0, y0) = from in
        let (x1, y1) = to in
        let tp = tail#padding in
        let hp = head#padding in
        let (a0, b0) = (x0 +' tp *' dx, y0 +' tp *' dy) in
        let (a1, b1) = (x1 -' hp *' dx, y1 -' hp *' dy) in
        let (a2, b2) = ((a0 +' a1) *' 0.5, (b0 +' b1) *' 0.5) in
        let (wx, wy) = (w3 *' dy, w3 *' dx) in
        let c1 = (a2 -' wx, b2 +' wy) in
        let c2 = (a2 +' wx, b2 -' wy) in
        let gr = stroke lw color (Gr.line c1 c2) in
        [gr]
      )
    ) in
    List.concat [gr-l1; gr-l2]
  );
|)

end

module NCSqArrowHead : sig

type t

val destruct : t -> context -> (
  (|
    % metadata of body
    mid-left : length;
    mid-right : length;
    end-left : length;
    end-right : length;
    min-len : length;
  |) ->
  (|
    metadata : (|
      padding : length;
      depth : length -> length;
    |);
    draw : float * float -> graphics list;
  |)
)

val none : t
% ->
val vee : t
% ->>
val vee-2 : t

end = struct

type body-metadata = (|
  mid-left : length;
  mid-right : length;
  end-left : length;
  end-right : length;
  min-len : length;
|)

type metadata = (|
  padding : length;
  depth : length -> length;
|)

type t = context -> body-metadata -> (|
  metadata: metadata;
  draw : float * float -> graphics list;
|)

let destruct head = head

let none ctx _ =
let pd = get-font-size ctx *' NCSqConst.pd-base in
(|
  metadata = (|
    padding = pd;
    depth = fun _ -> 0pt;
  |);
  draw = fun _ -> [];
|)

let vee ctx body =
let w0 = get-font-size ctx in
let color = get-text-color ctx in
let d0 = w0 *' NCSqConst.vee-min-width in
let d1 = Length.(max (max (abs body#end-left) (abs body#end-right)) d0) in
let d2 = w0 *' NCSqConst.vee-ext in
let d = d1 +' d2 in
let lw = w0 *' NCSqConst.line-width in
(|
  metadata = (|
    padding = w0 *' NCSqConst.pd-base +' d;
    depth = Length.abs;
  |);
  draw = fun (dx, dy) -> (
    let (x1, y1) = (d *' Float.neg (dx +. dy), d *' (dx -. dy)) in
    let (x2, y2) = (d *' (dy -. dx), d *' Float.neg (dx +. dy)) in
    let gr1 = stroke lw color (Gr.line (0pt, 0pt) (x1, y1)) in
    let gr2 = stroke lw color (Gr.line (0pt, 0pt) (x2, y2)) in
    [gr1; gr2]
  );
|)

let vee-shift = NCSqConst.vee-min-width *. 1.5

let vee-2 ctx body =
let v = vee ctx body in
let d = get-font-size ctx *' vee-shift in
let nd = Length.neg d in
(|
  v with
  metadata = (|
    v#metadata with
    padding = v#metadata#padding +' d;
  |);
  draw = fun (dx, dy) -> (
    let gr-l1 = v#draw (dx, dy) in
    let gr-l2 = List.map (shift-graphics (nd *' dx, nd *' dy)) gr-l1 in
    List.concat [gr-l1; gr-l2]
  );
|)

end

module NCSqArrowTail : sig

type t

val destruct : t -> context -> (
  (|
    % metadata of body
    mid-left : length;
    mid-right : length;
    end-left : length;
    end-right : length;
    min-len : length;
  |) ->
  (|
    metadata : (|
      padding : length;
      depth : length -> length;
    |);
    draw : float * float -> graphics list;
  |)
)

val none : t
% >-
val vee : t
% (_
val hook-l : t
% (‾
val hook-r : t

end = struct

type body-metadata = (|
  mid-left : length;
  mid-right : length;
  end-left : length;
  end-right : length;
  min-len : length;
|)

type metadata = (|
  padding : length;
  depth : length -> length;
|)

type t = context -> body-metadata -> (|
  metadata : metadata;
  draw : float * float -> graphics list;
|)

let destruct tail = tail

let none ctx _ =
let pd = get-font-size ctx *' 0.67 in
(|
  metadata = (|
    padding = pd;
    depth = fun _ -> 0pt;
  |);
  draw = fun _ -> [];
|)

let vee ctx body =
let w0 = get-font-size ctx in
let color = get-text-color ctx in
let d0 = w0 *' NCSqConst.vee-min-width in
let d1 = Length.(max (max (abs body#end-left) (abs body#end-right)) d0) in
let d2 = w0 *' NCSqConst.vee-ext in
let d = d1 +' d2 in
let lw = w0 *' NCSqConst.line-width in
(|
  metadata = (|
    padding = w0 *' NCSqConst.pd-base +' d;
    depth = fun x -> d -' (Length.abs x);
  |);
  draw = fun (dx, dy) -> (
    let (x0, y0) = (d *' dx, d *' dy) in
    let (x1, y1) = (Length.neg y0, x0) in
    let (x2, y2) = (y0, Length.neg x0) in
    let gr1 = stroke lw color (Gr.line (x0, y0) (x1, y1)) in
    let gr2 = stroke lw color (Gr.line (x0, y0) (x2, y2)) in
    [gr1; gr2]
  );
|)

% curve from (r, -r) to (r, r) via (0, 0)
% approximately a half circle
let hook-path r =
let t = r *' 0.55228 in             % cf. Gr.circle
let rt = r -' t in
let nr = Length.neg r in
start-path (r, nr)
|> bezier-to (rt, nr) (0pt, Length.neg t) (0pt, 0pt)
|> bezier-to (0pt, t) (rt, r) (r, r)
|> terminate-path

let hook-depth r y =
let yy = y /' 1pt in
let rr = r /' 1pt in
let s = yy /. rr in
let xx = rr *. (1.0 -. Float.sqrt(1.0 -. s *. s)) in
1pt *' xx

let hook-l-1 ctx body =
let fs = get-font-size ctx in
let w0 = fs *' NCSqConst.hook-min-width in
let w1 = body#end-right -' body#end-left in
let w2 = fs *' NCSqConst.hook-ext in
let w = (Length.(max w0 w1) +' w2) in
let r = w *' 0.5 in
let path = hook-path r in
let curve = hook-path r in
let centre = body#end-right -' r in
(|
  metadata = (|
    padding = fs *' NCSqConst.pd-base +' r;
    depth = fun y0 -> (
      let y = y0 -' centre in
      if Length.(y > r) then r
      else if Length.(y >= neg r) then hook-depth r y
      else r
    );
  |);
  curve = fun (dx, dy) -> (
    curve
    |> shift-path (0pt, 0pt -' centre)
    |> linear-transform-path dx (Float.neg dy) dy dx
  );
|)

let hook-l ctx body =
let h1 = hook-l-1 ctx body in
let lw = get-font-size ctx *' NCSqConst.line-width in
let color = get-text-color ctx in
(|
  metadata = h1#metadata;
  draw = fun (dx, dy) -> (
    let cv = h1#curve (dx, dy) in
    [stroke lw color cv]
  );
|)

let hook-r ctx body =
let h1 = hook-l-1 ctx (|
  body with
  end-left = Length.neg body#end-right;
  end-right = Length.neg body#end-left;
|) in
let lw = get-font-size ctx *' NCSqConst.line-width in
let color = get-text-color ctx in
(|
  metadata = (|
    h1#metadata with
    depth = fun y -> (h1#metadata#depth (Length.neg y));
  |);
  draw = fun (dx, dy) -> (
    let x2 = dx *. dx in
    let y2 = dy *. dy in
    let z = x2 -. y2 in
    let xy2 = 2.0 *. dx *. dy in
    let cv = (
      h1#curve (dx, dy)
      |> linear-transform-path z xy2 xy2 (Float.neg z)
    ) in
    [stroke lw color cv]
  );
|)

end

module NCSqArrowStyle : sig

type t

% ----->
val solid : t
% - - ->
val dashed : t
% =====
val equal : t
% =====>
val implies : t
% >---->
val tail : t
% ---->>
val two-heads : t
% (____>
val hook-l : t
% (‾‾‾‾>
val hook-r : t

val of-bth : NCSqArrowBody.t -> NCSqArrowTail.t -> NCSqArrowHead.t -> t

val destruct : t -> context -> (|
  body-left : length;
  body-right : length;
  body-length : length;
  tail-padding : length;
  head-padding : length;
  draw : point -> point -> graphics list
|)

end = struct

type body = NCSqArrowBody.t
type tail = NCSqArrowTail.t
type head = NCSqArrowHead.t

type t = body * tail * head

let of-bth body tail head = (body, tail, head)

let solid = of-bth NCSqArrowBody.solid NCSqArrowTail.none NCSqArrowHead.vee
let dashed = of-bth NCSqArrowBody.dashed NCSqArrowTail.none NCSqArrowHead.vee
let equal = of-bth NCSqArrowBody.solid-2 NCSqArrowTail.none NCSqArrowHead.none
let implies = of-bth NCSqArrowBody.solid-2 NCSqArrowTail.none NCSqArrowHead.vee
let tail = of-bth NCSqArrowBody.solid NCSqArrowTail.vee NCSqArrowHead.vee
let two-heads = of-bth NCSqArrowBody.solid NCSqArrowTail.none NCSqArrowHead.vee-2
let hook-l = of-bth NCSqArrowBody.solid NCSqArrowTail.hook-l NCSqArrowHead.vee
let hook-r = of-bth NCSqArrowBody.solid NCSqArrowTail.hook-r NCSqArrowHead.vee

let destruct (body, tail, head) ctx =
let b = NCSqArrowBody.destruct body ctx in
let bm = b#metadata in
let t = NCSqArrowTail.destruct tail ctx bm in
let h = NCSqArrowHead.destruct head ctx bm in
(|
  body-left = bm#mid-left;
  body-right = bm#mid-right;
  body-length = bm#min-len;
  tail-padding = t#metadata#padding;
  head-padding = h#metadata#padding;
  draw = fun from to -> (
    match NCSqUtil.angle from to with
    | None -> []
    | Some a -> (
      let grs-tail = List.map (shift-graphics from) (t#draw a) in
      let grs-body = b#draw t#metadata h#metadata from to in
      let grs-head = List.map (shift-graphics to) (h#draw a) in
      List.concat [grs-tail; grs-body; grs-head]
    )
  );
|)

end
