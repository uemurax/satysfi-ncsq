@require: pervasives
@require: base/list-ext
@require: base/option-ext
@require: base/length
@require: base/float
@require: gr
@import: ./ncsq-util

module NCSqConst : sig

val line-width : float
val vee-min-width : float
val vee-ext : float
val hook-min-width : float
val hook-ext : float
val pd-base : float

end = struct

let line-width = 0.042

let vee-min-width = 0.125
let vee-ext = 0.125
let hook-min-width = vee-min-width
let hook-ext = vee-ext *. 1.5

let pd-base = 0.67

end

module NCSqArrowBody : sig

type t

val destruct : t -> context -> (|
  left : length;
  right : length;
  draw : (
    (length -> length) ->       % tail depth
    (length -> length) ->       % head depth
    point ->                    % from
    point ->                    % to
    graphics list
  );
|)

val none : t
val solid : t
% double solid lines =====
val solid-2 : t
val multi-solid : int -> t
val dashed : t
% double dashed lines = = =
val dashed-2 : t
val multi-dashed : int -> t

end = struct

type t = context -> (|
  left : length;
  right : length;
  draw : (length -> length) -> (length -> length) -> point -> point -> graphics list;
|)

let destruct body = body

let none ctx = (|
  left = 0pt;
  right = 0pt;
  draw = fun _ _ _ _ -> [];
|)

let shift ((x0, y0), (x1, y1)) p =
NCSqUtil.angle (x0, y0) (x1, y1)
|> Option.map (fun (dx, dy) -> (
  let dx0 = p *' dx in
  let dy0 = p *' dy in
  ((x0 +' dy0, y0 -' dx0), (x1 +' dy0, y1 -' dx0))
))

let of-lines lf-l0 ctx =
let fs = get-font-size ctx in
let lf-l = List.map (fun (x, f) -> (fs *' x, f ctx)) lf-l0 in
let left = List.fold-right (fun (pos, _) l -> Length.(min l pos)) 0pt lf-l in
let right = List.fold-right (fun (pos, _) r -> Length.(max r pos)) 0pt lf-l in
let-rec aux gr-ll lf-l tail head from to = (
  match lf-l with
  | [] -> List.concat gr-ll
  | (pos, lf) :: lf-l1 -> (
    let gr-ll1 = (
      match shift (from, to) pos with
      | None -> gr-ll
      | Some (z, w) -> (
        let gr-l = lf z w (tail pos) (head pos) in
        gr-l :: gr-ll
      )
    ) in
    aux gr-ll1 lf-l1 tail head from to
  )
) in
(|
  left = left;
  right = right;
  draw = aux [] lf-l;
|)

let line-end-points from to t0 h0 =
NCSqUtil.angle from to
|> Option.map (fun (dx, dy) -> (
  let (x0, y0) = from in
  let (x1, y1) = to in
  let a0 = x0 +' t0 *' dx in
  let b0 = y0 +' t0 *' dy in
  let a1 = x1 -' h0 *' dx in
  let b1 = y1 -' h0 *' dy in
  ((a0, b0), (a1, b1))
))

let line ctx =
let fs = get-font-size ctx in
let c = get-text-color ctx in
fun x y t h -> (
  match line-end-points x y t h with
  | None -> []
  | Some (a, b) -> (
    [stroke (fs *' NCSqConst.line-width) c (Gr.line a b)]
  )
)

let multi-lines n lf =
let p = NCSqConst.line-width *. 2.0 in
let q = p *. 2.0 in
let b = Float.(neg (p *. of-int (n - 1))) in
let-rec aux ls x m = (
  if m <= 0 then ls
  else aux ((x, lf) :: ls) (x +. q) (m - 1)
) in
of-lines (aux [] b n)

let multi-solid n = multi-lines n line

let solid = multi-solid 1
let solid-2 = multi-solid 2

let dashed-line ctx =
let fs = get-font-size ctx in
let d1 = fs *' 0.25 in
let d2 = d1 in
let c = get-text-color ctx in
fun x y t h -> (
  match line-end-points x y t h with
  | None -> []
  | Some (a, b) -> (
    let w = fs *' NCSqConst.line-width in
    let dash = (d1, d2, t) in
    [dashed-stroke w dash c (Gr.line a b)]
  )
)

let multi-dashed n = multi-lines n dashed-line

let dashed = multi-dashed 1
let dashed-2 = multi-dashed 2

end

module NCSqArrowHead : sig

type t

val destruct : t -> context -> (
  length ->                     % body left
  length ->                     % body right
  (|
    padding : length;
    depth : length -> length;
    draw : float * float -> graphics list;
  |)
)

val none : t
% ->
val vee : t
% ->>
val vee-2 : t

end = struct

type t = context -> length -> length -> (|
  padding : length;
  depth : length -> length;
  draw : float * float -> graphics list;
|)

let destruct head = head

let none ctx _ _ =
let pd = get-font-size ctx *' NCSqConst.pd-base in
(|
  padding = pd;
  depth = fun _ -> 0pt;
  draw = fun _ -> [];
|)

let vee ctx left right =
let w0 = get-font-size ctx in
let color = get-text-color ctx in
let d0 = w0 *' NCSqConst.vee-min-width in
let d1 = Length.(max (max (abs left) (abs right)) d0) in
let d2 = w0 *' NCSqConst.vee-ext in
let d = d1 +' d2 in
let lw = w0 *' NCSqConst.line-width in
(|
  padding = w0 *' NCSqConst.pd-base +' d;
  depth = Length.abs;
  draw = fun (dx, dy) -> (
    let (x1, y1) = (d *' Float.neg (dx +. dy), d *' (dx -. dy)) in
    let (x2, y2) = (d *' (dy -. dx), d *' Float.neg (dx +. dy)) in
    let gr1 = stroke lw color (Gr.line (0pt, 0pt) (x1, y1)) in
    let gr2 = stroke lw color (Gr.line (0pt, 0pt) (x2, y2)) in
    [gr1; gr2]
  );
|)

let vee-shift = NCSqConst.vee-min-width *. 1.5

let vee-2 ctx left right =
let v = vee ctx left right in
let d = get-font-size ctx *' vee-shift in
let nd = Length.neg d in
(|
  v with
  padding = v#padding +' d;
  draw = fun (dx, dy) -> (
    let gr-l1 = v#draw (dx, dy) in
    let gr-l2 = List.map (shift-graphics (nd *' dx, nd *' dy)) gr-l1 in
    List.concat [gr-l1; gr-l2]
  );
|)

end

module NCSqArrowTail : sig

type t

val destruct : t -> context -> (
  length ->                     % body left
  length ->                     % body right
  (|
    padding : length;
    depth : length -> length;
    draw : float * float -> graphics list;
  |)
)

val none : t
% >-
val vee : t
% (_
val hook-l : t
% (â€¾
val hook-r : t

end = struct

type t = context -> length -> length -> (|
  padding : length;
  depth : length -> length;
  draw : float * float -> graphics list;
|)

let destruct tail = tail

let none ctx _ _ =
let pd = get-font-size ctx *' 0.67 in
(|
  padding = pd;
  depth = fun _ -> 0pt;
  draw = fun _ -> [];
|)

let vee ctx left right =
let w0 = get-font-size ctx in
let color = get-text-color ctx in
let d0 = w0 *' NCSqConst.vee-min-width in
let d1 = Length.(max (max (abs left) (abs right)) d0) in
let d2 = w0 *' NCSqConst.vee-ext in
let d = d1 +' d2 in
let lw = w0 *' NCSqConst.line-width in
(|
  padding = w0 *' NCSqConst.pd-base +' d;
  depth = fun x -> d -' (Length.abs x);
  draw = fun (dx, dy) -> (
    let (x0, y0) = (d *' dx, d *' dy) in
    let (x1, y1) = (Length.neg y0, x0) in
    let (x2, y2) = (y0, Length.neg x0) in
    let gr1 = stroke lw color (Gr.line (x0, y0) (x1, y1)) in
    let gr2 = stroke lw color (Gr.line (x0, y0) (x2, y2)) in
    [gr1; gr2]
  );
|)

% curve from (r, -r) to (r, r) via (0, 0)
% approximately a half circle
let hook-path r =
let t = r *' 0.55228 in             % cf. Gr.circle
let rt = r -' t in
let nr = Length.neg r in
start-path (r, nr)
|> bezier-to (rt, nr) (0pt, Length.neg t) (0pt, 0pt)
|> bezier-to (0pt, t) (rt, r) (r, r)
|> terminate-path

let hook-depth r y =
let yy = y /' 1pt in
let rr = r /' 1pt in
let s = yy /. rr in
let xx = rr *. (1.0 -. Float.sqrt(1.0 -. s *. s)) in
1pt *' xx

let hook-l-1 ctx left right =
let fs = get-font-size ctx in
let w0 = fs *' NCSqConst.hook-min-width in
let w1 = right -' left in
let w2 = fs *' NCSqConst.hook-ext in
let w = (Length.(max w0 w1) +' w2) in
let r = w *' 0.5 in
let path = hook-path r in
let curve = hook-path r in
let centre = right -' r in
(|
  padding = fs *' NCSqConst.pd-base +' r;
  depth = fun y0 -> (
    let y = y0 -' centre in
    if Length.(y > r) then r
    else if Length.(y >= neg r) then hook-depth r y
    else r
  );
  curve = fun (dx, dy) -> (
    curve
    |> shift-path (0pt, 0pt -' centre)
    |> linear-transform-path dx (Float.neg dy) dy dx
  );
|)

let hook-l ctx left right =
let h1 = hook-l-1 ctx left right in
let lw = get-font-size ctx *' NCSqConst.line-width in
let color = get-text-color ctx in
(|
  padding = h1#padding;
  depth = h1#depth;
  draw = fun (dx, dy) -> (
    let cv = h1#curve (dx, dy) in
    [stroke lw color cv]
  );
|)

let hook-r ctx left right =
let h1 = hook-l-1 ctx (Length.neg right) (Length.neg left) in
let lw = get-font-size ctx *' NCSqConst.line-width in
let color = get-text-color ctx in
(|
  padding = h1#padding;
  depth = fun y -> (h1#depth (Length.neg y));
  draw = fun (dx, dy) -> (
    let x2 = dx *. dx in
    let y2 = dy *. dy in
    let z = x2 -. y2 in
    let xy2 = 2.0 *. dx *. dy in
    let cv = (
      h1#curve (dx, dy)
      |> linear-transform-path z xy2 xy2 (Float.neg z)
    ) in
    [stroke lw color cv]
  );
|)

end

module NCSqArrowStyle : sig

type t

val of-bth : NCSqArrowBody.t -> NCSqArrowTail.t -> NCSqArrowHead.t -> t

val destruct : t -> context -> (|
  left : length;
  right : length;
  tail-padding : length;
  head-padding : length;
  draw : point -> point -> graphics list
|)

end = struct

type body = NCSqArrowBody.t
type tail = NCSqArrowTail.t
type head = NCSqArrowHead.t

type t = body * tail * head

let of-bth body tail head = (body, tail, head)

let destruct (body, tail, head) ctx =
let b = NCSqArrowBody.destruct body ctx in
let l = b#left in
let r = b#right in
let t = NCSqArrowTail.destruct tail ctx l r in
let h = NCSqArrowHead.destruct head ctx l r in
(|
  left = l;
  right = r;
  tail-padding = t#padding;
  head-padding = h#padding;
  draw = fun from to -> (
    match NCSqUtil.angle from to with
    | None -> []
    | Some a -> (
      let grs-tail = List.map (shift-graphics from) (t#draw a) in
      let grs-body = b#draw t#depth h#depth from to in
      let grs-head = List.map (shift-graphics to) (h#draw a) in
      List.concat [grs-tail; grs-body; grs-head]
    )
  );
|)

end
