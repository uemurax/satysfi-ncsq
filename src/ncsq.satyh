@require: pervasives
@require: base/list-ext
@require: base/tuple
@require: base/length
@require: base/option-ext
@require: gr
@require: math
@import: ./base/qp
@import: ./base/real-matrix
@import: ./base/interval
@import: ./base/rect
@import: ./ncsq-util
@import: ./arrows
@import: ./cells

% Name conventions
% -l or -ls: list of something
% -ll: list of lists of something
% -lll: list of lists of lists of something
% -o: option of something

module NCSq : sig

type cell
type direction1
type arrow-direction

val \cd : [(cell list) list] inline-cmd
val +cd : [(cell list) list] block-cmd
val \cd-m : [(cell list) list] math-cmd

% Building cells

val empty : cell
val object : float * float * float * float ?-> math -> cell
val arrow : math ?-> math ?-> NCSqArrowStyle.t ?-> arrow-direction -> cell
val arrow-2 : math ?-> float * float * float * float ?-> arrow-direction -> cell
val eqarrow : arrow-direction -> cell
val stack : direction1 -> cell list -> cell

% Arrow directions

val horizontal : direction1
val vertical : direction1
val left : arrow-direction
val right : arrow-direction
val up : arrow-direction
val down : arrow-direction

% Arrow style

val solid : NCSqArrowStyle.t
val dashed : NCSqArrowStyle.t
val equal : NCSqArrowStyle.t

% Utilities

val transpose : (cell list) list -> (cell list) list
val invert-v : (cell list) list -> (cell list) list
val invert-h : (cell list) list -> (cell list) list

end = struct

type cell-raw =
| Empty-raw
| Object-raw of NCSqObject.t
| Arrow-raw of NCSqArrow.t

module Cell-raw : sig

val face : NCSqDirection.t -> cell-raw -> Interval.t
val front : NCSqDirection.t -> cell-raw -> length
val back : NCSqDirection.t -> cell-raw -> length

end = struct

let face dir cell =
match cell with
| Empty-raw -> Interval.zero
| Object-raw obj -> NCSqRect.face dir (NCSqObject.bbox obj)
| Arrow-raw arr -> (
  let differ _ = Interval.neg (NCSqArrow.face arr) in
  let same _ = Interval.zero in
  let dir1 = NCSqArrow.direction arr in
  NCSqDirection.elim (|
    h = fun _ -> NCSqDirection.elim (|
      h = same;
      v = differ;
    |) dir1;
    v = fun _ -> NCSqDirection.elim (|
      h = differ;
      v = same;
    |) dir1;
  |) dir
)

let front dir cell = NCSqInterval.front dir (face dir cell)
let back dir cell = NCSqInterval.back dir (face dir cell)

end

let cells-face dir =
List.fold-right (fun cell itv -> (
  let itv1 = Cell-raw.face dir cell in
  Interval.union itv itv1
)) Interval.zero

let cellss-faces dir = List.map (cells-face dir)
let cellss-bts cell-ll = cellss-faces NCSqDirection.v cell-ll
let cellss-lrs cell-ll = cellss-faces NCSqDirection.h (NCSqUtil.transpose Empty-raw cell-ll)

% Determine source and target of an arrow

% Find the first object in a list of cells
let find-object cx-l =
let-rec aux x-l y-l = (
  match y-l with
  | [] -> (x-l, None, [])
  | y :: y-l1 ->
  (match y with
   | (Object-raw _, _) -> (x-l, Some y, y-l1)
   | _ -> aux (y :: x-l) y-l1)
) in
aux [] cx-l

% Find the first virtical/horizontal arrow in a list of cells
let find-arrow dir cx-l0 obx cx-l =
let-rec aux x-l src y-l z-l = (
  match z-l with
  | [] -> (x-l, src, y-l, None, [])
  | z :: z-l1 -> (
    let fallback _ = aux x-l src (z :: y-l) z-l1 in
    match z with
    | (Object-raw _, _) -> aux (List.append y-l (src :: x-l)) z [] z-l1
    | (Arrow-raw arr, _) -> (
      let same _ = (x-l, src, y-l, Some z, z-l1) in
      let differ = fallback in
      let dir1 = NCSqArrow.direction arr in
      NCSqDirection.elim (|
        h = fun _ -> NCSqDirection.elim (|
          h = same;
          v = differ;
        |) dir1;
        v = fun _ -> NCSqDirection.elim (|
          h = differ;
          v = same;
        |) dir1;
      |) dir
    )
    | _ -> fallback ()
  )
)in
aux cx-l0 obx [] cx-l

let find-varrow = find-arrow NCSqDirection.v

let find-harrow = find-arrow NCSqDirection.h

% Adjust boundaries of cells

let d-sum =
List.fold-right (fun (_, (itv, _)) l -> (
  l +' Interval.width itv
)) 0pt

let make-qp-1-1 x-ls src y-ls cx z-ls tgt w-ls =
let (cell, (bd, fs)) = cx in
let fallback _ = (None, cx) in
match cell with
| Arrow-raw arr -> (
  let al = NCSqArrow.min-len arr in
  let cl = Interval.width bd in
  let yl = d-sum y-ls in
  let zl = d-sum z-ls in
  let (s, (sbd, _)) = src in
  let (t, (tbd, _)) = tgt in
  let dir = NCSqArrow.direction arr in
  let sl = Length.abs (Cell-raw.front dir s -' NCSqInterval.front dir sbd) in
  let tl = Length.abs (Cell-raw.back dir  t -' NCSqInterval.back dir tbd) in
  let d = al -' yl -' cl -' zl -' sl -' tl in
  if 0pt <' d then (
    let (tc, sc) = NCSqDirection.elim (|
      h = fun _ -> ((1.0, 0.0), (0.0, 1.0));
      v = fun _ -> ((0.0, 1.0), (1.0, 0.0));
    |) dir in
    let f0 _ = (0.0, 0.0) in
    let f1 _ = (1.0, 1.0) in
    let cstr = List.(
      map f0 w-ls
      |> cons tc        % tgt
      |> reverse-append (map f1 z-ls)
      |> cons (1.0, 1.0)          % arr
      |> reverse-append (map f1 y-ls)
      |> cons sc        % src
      |> reverse-append (map f0 x-ls)
    ) in
    let (fsp, fsq) = fs in
    let dd = d *' 0.55 in
    (Some (cstr, d), (cell, (bd, (fsp +' dd, fsq +' dd))))
  ) else fallback ()
)
| _ -> fallback ()

let make-qp-1 dir1 cell-l (cstr-l, pq-l) =
let cpq-l = NCSqUtil.zip Empty-raw (Interval.zero, (0pt, 0pt)) cell-l pq-l in
let (x-l, src, y-l) = find-object cpq-l in
match src with
| None -> (cstr-l, pq-l)
| Some src -> (
  let-rec aux cstr-l x-l src y-l = (
    let (x-l, src, y-l, arr, z-l) = find-arrow dir1 x-l src y-l in
    match arr with
    | None -> (cstr-l, List.(
      z-l
      |> reverse-append y-l
      |> cons src
      |> reverse-append x-l
    ))
    | Some arr -> (
      let (z-l, tgt, w-l) = find-object z-l in
      match tgt with
      | None -> (cstr-l, List.(
        w-l
        |> reverse-append z-l
        |> cons arr
        |> reverse-append y-l
        |> cons src
        |> reverse-append x-l
      ))
      | Some tgt -> (
        let (cstro, arr) = make-qp-1-1 x-l src y-l arr z-l tgt w-l in
        let cstr-l =
        match cstro with
        | None -> cstr-l
        | Some cstr -> cstr :: cstr-l
        in
        aux cstr-l List.(append z-l (arr :: append y-l (src :: x-l))) tgt w-l
      )
    )
  ) in
  let (cstr-l, cpq-l) = aux cstr-l x-l src y-l in
  (cstr-l, List.map Pair.snd cpq-l)
)

let make-qp dir1 cell-ll pq-l =
let pq-l1 = NCSqUtil.zip Interval.zero (0pt, 0pt) pq-l [] in
let (cstr-l, pq-l2) = List.fold-right (make-qp-1 dir1) ([], pq-l1) cell-ll in
(cstr-l, List.map Pair.snd pq-l2)

let-rec part-2 x-l =
match x-l with
| x :: y :: x-l1 -> (x, y) :: part-2 x-l1
| _ -> []

let len-to-f x = x /' 1pt
let f-to-len x = 1pt *' x

let solve-qp (cstr-l, pq-l) =
let f z-l = List.(concat (map (fun (x, y) -> [x; y]) z-l)) in
let ls = f pq-l in
let n = List.length ls in
let x = RealVector.of-list (List.map len-to-f ls) in
let (a1, b1) = List.unzip cstr-l in
let a2 = List.map (fun z-l -> RealVector.of-list (f z-l)) a1 in
let b2 = List.map len-to-f b1 in
let v = RealVector.of-list (List.append (List.repeat n 0.0) b2) in
let bs = RealVector.basis n in
let mx = RealMatrix.of-list n (List.append bs a2) in
let y = QP.solve mx v x in
part-2 (List.map f-to-len (RealVector.to-list y))

let adjust-cellss-faces dir1 cell-ll pq-l =
let problem = make-qp dir1 cell-ll pq-l in
match problem with
| ([], _) -> pq-l
| _ -> (
  let pq-l1 = solve-qp problem in
  NCSqUtil.zip-with (fun pq-o1 pq-o2 -> (
    let pq1 = Option.from Interval.zero pq-o1 in
    let (x, y) = Option.from (0pt, 0pt) pq-o2 in
    Interval.expand x y pq1
  )) pq-l pq-l1
)

let adjust-cellss-bts cell-ll = adjust-cellss-faces NCSqDirection.v (NCSqUtil.transpose Empty-raw cell-ll)

let adjust-cellss-lrs = adjust-cellss-faces NCSqDirection.h

% Draw cells

let make-grid dir1 bd-l =
let (x-l, _) = (
  List.fold-right (fun bd (x-l, x) -> (
    (let x1 = x -' NCSqInterval.front dir1 bd in
     (x1 :: x-l, x1 +' NCSqInterval.back dir1 bd))
  )) ([], 0pt) bd-l
) in
x-l

let make-vgrid = make-grid NCSqDirection.v

let make-hgrid = make-grid NCSqDirection.h

let draw-objects vgrid hgrid cell-ll =
let gr-lll =
NCSqUtil.zip-with
(fun y-o cell-l-o ->
 (let y = Option.from 0pt y-o in
  let cell-l = Option.from [] cell-l-o in
  NCSqUtil.zip-with
  (fun x-o cell-o ->
   (let x = Option.from 0pt x-o in
    let cell = Option.from Empty-raw cell-o in
    match cell with
    | Object-raw obj -> List.(
      NCSqObject.draw obj
      |> map (shift-graphics (x, y))
    )
    | _ -> []))
  hgrid cell-l))
vgrid cell-ll in
List.concat (List.concat gr-lll)

let draw-arrow dir z src cx tgt =
let (cell, _) = cx in
let fallback _ = [] in
match cell with
| Arrow-raw arr -> (
  let differ = fallback in
  let same _ = (
    let (s, sc) = src in
    let (t, tc) = tgt in
    let s-front = sc +' Cell-raw.front dir s in
    let t-back = tc +' Cell-raw.back dir t in
    let gr-l = NCSqArrow.draw (Length.abs (t-back -' s-front)) arr in
    let sh = NCSqDirection.elim (|
      h = fun _ -> (s-front, z);
      v = fun _ -> (z, s-front);
    |) dir in
    List.map (shift-graphics sh) gr-l
  ) in
  let dir1 = NCSqArrow.direction arr in
  NCSqDirection.elim (|
    h = fun _ -> NCSqDirection.elim (|
      h = same;
      v = differ;
    |) dir1;
    v = fun _ -> NCSqDirection.elim (|
      h = differ;
      v = same;
    |) dir1;
  |) dir
)
| _ -> fallback ()

let draw-arrows dir1 vgrid hgrid cell-ll =
let gr-ll =
NCSqUtil.zip-with
(fun x-o cell-l-o ->
 (let x = Option.from 0pt x-o in
  let cell-l = Option.from [] cell-l-o in
  let cx-l = NCSqUtil.zip Empty-raw 0pt cell-l vgrid in
  let (_, src, y-l) = find-object cx-l in
  match src with
  | None -> []
  | Some src ->
  (let-rec aux src y-l =
   let (_, src, _, arr, z-l) = find-arrow dir1 [] src y-l in
   match arr with
   | None -> []
   | Some arr ->
   (let (_, tgt, w-l) = find-object z-l in
    match tgt with
    | None -> []
    | Some tgt ->
    (let gr-l = draw-arrow dir1 x src arr tgt in
     List.append gr-l (aux tgt w-l)))
   in
   aux src y-l)))
hgrid cell-ll in
List.concat gr-ll

let draw-varrows vgrid hgrid cell-ll = draw-arrows NCSqDirection.v vgrid hgrid (NCSqUtil.transpose Empty-raw cell-ll)

let draw-harrows vgrid hgrid = draw-arrows NCSqDirection.h hgrid vgrid

let draw-diagram cell-ll =
let bt-l0 = cellss-bts cell-ll in
let bt-l = adjust-cellss-bts cell-ll bt-l0 in
let lr-l0 = cellss-lrs cell-ll in
let lr-l = adjust-cellss-lrs cell-ll lr-l0 in
let vgrid = make-vgrid bt-l in
let hgrid = make-hgrid lr-l in
let obj-l = draw-objects vgrid hgrid cell-ll in
let varr-l = draw-varrows vgrid hgrid cell-ll in
let harr-l = draw-harrows vgrid hgrid cell-ll in
List.concat [obj-l; varr-l; harr-l]

% Commands

type direction1 = NCSqDirection.t

type direction2 =
| Forwards
| Backwards

type arrow-direction = direction1 * direction2

type object = (|
  label : math;
  paddings : float * float * float * float;
|)

type arrow = (|
  direction : arrow-direction;
  style : NCSqArrowStyle.t;
  left-label : math option;
  right-label : math option;
|)

type arrow-2 = (|
  label : math option;
  paddings : float * float * float * float;
  direction : arrow-direction;
|)

type cell =
| Empty
| Object of object
| Arrow of arrow
| Arrow-2 of arrow-2
| Stack of direction1 * cell list

let horizontal = NCSqDirection.h
let vertical = NCSqDirection.v
let left = (horizontal, Backwards)
let right = (horizontal, Forwards)
let up = (vertical, Backwards)
let down = (vertical, Forwards)

let empty = Empty

let object ?:pds-opt label =
Object (|
  label = label;
  paddings = Option.from (let pd = 0.25 in (pd, pd, pd, pd)) pds-opt;
|)

let arrow ?:left-label-o ?: right-label-o ?:style-o direction =
Arrow (|
  direction = direction;
  style = (
    Option.from
    (NCSqArrowStyle.of-bth NCSqArrowBody.solid NCSqArrowTail.none NCSqArrowHead.vee)
    style-o
  );
  left-label = left-label-o;
  right-label = right-label-o;
|)

let arrow-2 ?:label-o ?:pds-o direction =
Arrow-2 (|
  label = label-o;
  paddings = Option.from (let (pdx, pdy) = (0.5, 0.25) in (pdx, pdx, pdy, pdy)) pds-o;
  direction = direction;
|)

let stack dir cell-l = Stack (dir, cell-l)

let solid = NCSqArrowStyle.solid
let dashed = NCSqArrowStyle.dashed
let equal = NCSqArrowStyle.equal

let eqarrow direction = arrow ?* ?* ?:(equal) direction

let label-context ctx = set-font-size (get-font-size ctx *' 0.75) ctx

let shift-y = 0.33

let make-object ctx obj = NCSqObject.of-math ctx obj#paddings (Float.neg shift-y) obj#label

let label-ctx ctx =
let fs = get-font-size ctx in
ctx
|> set-font-size (fs *' 0.75)

let make-arrow ctx arr = (
  let (dir1, dir2) = arr#direction in
  let (ml, mr, style) = (
    match dir2 with
    | Forwards -> (arr#left-label, arr#right-label, arr#style)
    | Backwards -> (arr#right-label, arr#left-label, NCSqArrowStyle.invert arr#style)
  ) in
  let dir = Pair.fst arr#direction in
  NCSqArrow.of-style-with-mlabels (label-ctx ctx) ml mr (0.3, 0.3) style dir
)

let make-cell-raw ctx cell =
match cell with
| Empty -> Empty-raw
| Object obj -> Object-raw (make-object ctx obj)
| Arrow arr -> Arrow-raw (make-arrow ctx arr)
| Arrow-2 arr2 -> (
  let (dir1, dir2) = arr2#direction in
  let m1 = NCSqDirection.elim (|
    h = fun _ -> (
      match dir2 with
      | Backwards -> ${\Leftarrow}
      | Forwards -> ${\Rightarrow}
    );
    v = fun _ -> (
      match dir2 with
      | Backwards -> ${\Uparrow}
      | Forwards -> ${\Downarrow}
    );
  |) dir1 in
  let m = (
    match arr2#label with
    | None -> m1
    | Some l1 -> (
      let l = text-in-math MathOrd (
        fun ctx -> read-inline (label-ctx ctx) {${#l1}}
      ) in
      NCSqDirection.elim (|
        h = fun _ -> ${\upper{#m1}{#l}};
        v = fun _ -> ${\mathord{#m1} #l};
      |) dir1
    )
  ) in
  Object-raw (make-object ctx (|
    label = m;
    paddings = arr2#paddings;
  |))
)
| Stack (dir, cell-l) -> (
  let-rec aux ls cell-l = (
    match cell-l with
    | [] -> NCSqDirection.elim (|
      h = fun _ -> ls;
      v = fun _ -> List.reverse ls;
    |) dir
    | cell :: cell-l-1 -> (
      let ls-1 = (
        let fallback _ = ls in
        match cell with
        | Object obj -> NCSqArrow.of-object (make-object (label-ctx ctx) obj) :: ls
        | Arrow arr1 -> (
          let arr = make-arrow ctx arr1 in
          let dir1 = NCSqArrow.direction arr in
          let same = fallback in
          let differ _ = (fun _ -> arr) :: ls in
          NCSqDirection.elim (|
            h = fun _ -> (
              NCSqDirection.elim (|
                h = same;
                v = differ;
              |) dir1
            );
            v = fun _ -> (
              NCSqDirection.elim (|
                h = differ;
                v = same;
              |) dir1
            );
          |) dir
        )
        | _ -> fallback ()
      ) in
      aux ls-1 cell-l-1
    )
  ) in
  Arrow-raw (NCSqArrow.of-list (aux [] cell-l) (NCSqDirection.flip dir))
)

let cd ctx cell-ll =
let fs = get-font-size ctx in
let gr-l = draw-diagram (List.map (List.map (make-cell-raw ctx)) cell-ll) in
let rc = List.(
  gr-l
  |> map get-graphics-bbox
  |> map Rect.of-rect
  |> fold-right Rect.union Rect.zero
) in
let yc = Interval.center (Rect.interval-v rc) in
let ym = yc -' fs *' shift-y in
let ((x0, y0), (x1, y1)) = Rect.to-rect rc in
let w = x1 -' x0 in
let h = y1 -' ym in
let d = ym -' y0 in
inline-graphics w h d
(fun (px, py) ->
 (List.map (shift-graphics (px -' x0, py -' ym)) gr-l))

let-block ctx +cd cell-ll =
line-break true true ctx (inline-fil ++ cd ctx cell-ll ++ inline-fil)

let-inline ctx \cd cell-ll =
inline-fil ++ embed-block-breakable ctx (read-block ctx '<+cd(cell-ll);>)

let-math \cd-m cell-ll =
text-in-math MathOrd (fun ctx -> cd ctx cell-ll)

% Utilities

let invert-direction-vertically dir =
let (dir1, dir2) = dir in
NCSqDirection.elim (|
  h = fun _ -> dir;
  v = fun _ -> (
    let d2 = (
      match dir2 with
      | Backwards -> Forwards
      | Forwards ->  Backwards
    ) in
    (NCSqDirection.v, d2)
  );
|) dir1

let-rec invert-cell-vertically cell =
match cell with
| Arrow arr ->
(Arrow (|
  arr with
  left-label = arr#right-label;
  right-label = arr#left-label;
  direction = invert-direction-vertically arr#direction;
|))
| Arrow-2 arr-2 ->
(Arrow-2 (|
  arr-2 with
  direction = invert-direction-vertically arr-2#direction;
|))
| Stack (dir, cell-l) -> (
  let map = NCSqDirection.elim (|
    h = fun _ -> List.map;
    v = fun _ -> List.reverse-map;
  |) dir in
  Stack (dir, map invert-cell-vertically cell-l)
)
| _ -> cell

let invert-v cell-ll = List.map (List.map invert-cell-vertically) (List.reverse cell-ll)

let transpose-direction dir =
let (dir1, dir2) = dir in
(NCSqDirection.flip dir1, dir2)

let-rec transpose-cell cell =
match cell with
| Arrow arr ->
(Arrow (|
  arr with
  left-label = arr#right-label;
  right-label = arr#left-label;
  direction = transpose-direction arr#direction;
|))
| Arrow-2 arr-2 ->
(Arrow-2 (|
  arr-2 with
  direction = transpose-direction arr-2#direction;
|))
| Stack (dir, cell-l) -> Stack (NCSqDirection.flip dir, List.map transpose-cell cell-l)
| _ -> cell

let transpose cell-ll = List.map (List.map transpose-cell) (NCSqUtil.transpose empty cell-ll)

let invert-h cell-ll = transpose (invert-v (transpose cell-ll))

end
