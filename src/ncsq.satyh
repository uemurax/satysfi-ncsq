@require: pervasives
@require: base/list-ext
@require: base/tuple
@require: base/length
@require: base/option-ext
@require: gr
@require: math
@import: ./qp
@import: ./matrix

% Name conventions
% -l or -ls: list of something
% -ll: list of lists of something
% -lll: list of lists of lists of something
% -o: option of something

% This type is DEPRECATED. Will be removed in v1
type ncsq-arrow-style =
| Solid
| Dashed

module NCSq : sig

type cell
type arrow-style
type arrow-direction

val \cd : [(cell list) list] inline-cmd
val +cd : [(cell list) list] block-cmd
val \cd-m : [(cell list) list] math-cmd

% Building cells

val empty : cell
val object : length * length * length * length ?-> inline-text -> cell
val arrow : inline-text ?-> inline-text ?-> arrow-style ?-> arrow-direction -> cell
val arrow-2 : inline-text ?-> length * length * length * length ?-> arrow-direction -> cell
val eqarrow : arrow-direction -> cell

% Arrow directions

val left : arrow-direction
val right : arrow-direction
val up : arrow-direction
val down : arrow-direction

% Arrow styles

val solid : arrow-style
val dashed : arrow-style
val equal : arrow-style

% Utilities

val transpose : (cell list) list -> (cell list) list
val invert-v : (cell list) list -> (cell list) list
val invert-h : (cell list) list -> (cell list) list

% The following are DEPRECATED. Will be removed in v1

type cell-raw

val \diagram : [(|
  emp : cell-raw;
  obj : inline-text -> cell-raw;
  larr : ncsq-arrow-style ?-> inline-text -> inline-text -> cell-raw;
  rarr : ncsq-arrow-style ?-> inline-text -> inline-text -> cell-raw;
  uarr : ncsq-arrow-style ?-> inline-text -> inline-text -> cell-raw;
  darr : ncsq-arrow-style ?-> inline-text -> inline-text -> cell-raw;
  heq : cell-raw;
  veq : cell-raw;
  arr2 : inline-text -> cell-raw;
  harr : ncsq-arrow-style ?-> inline-text -> inline-text -> cell-raw;
  varr : ncsq-arrow-style ?-> inline-text -> inline-text -> cell-raw;
|) -> (cell-raw list) list] inline-cmd

val +diagram : [(|
  emp : cell-raw;
  obj : inline-text -> cell-raw;
  larr : ncsq-arrow-style ?-> inline-text -> inline-text -> cell-raw;
  rarr : ncsq-arrow-style ?-> inline-text -> inline-text -> cell-raw;
  uarr : ncsq-arrow-style ?-> inline-text -> inline-text -> cell-raw;
  darr : ncsq-arrow-style ?-> inline-text -> inline-text -> cell-raw;
  heq : cell-raw;
  veq : cell-raw;
  arr2 : inline-text -> cell-raw;
  harr : ncsq-arrow-style ?-> inline-text -> inline-text -> cell-raw;
  varr : ncsq-arrow-style ?-> inline-text -> inline-text -> cell-raw;
|) -> (cell-raw list) list] block-cmd

val \diagram-m : [(|
  emp : cell-raw;
  obj : inline-text -> cell-raw;
  larr : ncsq-arrow-style ?-> inline-text -> inline-text -> cell-raw;
  rarr : ncsq-arrow-style ?-> inline-text -> inline-text -> cell-raw;
  uarr : ncsq-arrow-style ?-> inline-text -> inline-text -> cell-raw;
  darr : ncsq-arrow-style ?-> inline-text -> inline-text -> cell-raw;
  heq : cell-raw;
  veq : cell-raw;
  arr2 : inline-text -> cell-raw;
  harr : ncsq-arrow-style ?-> inline-text -> inline-text -> cell-raw;
  varr : ncsq-arrow-style ?-> inline-text -> inline-text -> cell-raw;
|) -> (cell-raw list) list] math-cmd

end = struct

type direction1 =
| Horizontal
| Vertical

type direction2 =
| Forwards
| Backwards

type arrow-direction = direction1 * direction2

type arrow-config = (|
  head-len : length;
  tail-len : length;
  draw : point -> point -> graphics list;
|)

type paddings = length * length * length * length

type cell-raw =
| Empty-raw
| Object-raw of graphics * paddings
| Arrow-raw of arrow-config * arrow-direction * graphics list

% Utilities

let-rec zip-with f x-l y-l =
match (x-l, y-l) with
| ([], _) -> List.map (fun y -> (f None (Some y))) y-l
| (_, []) -> List.map (fun x -> (f (Some x) None)) x-l
| (x :: x-l1, y :: y-l1) -> f (Some x) (Some y) :: zip-with f x-l1 y-l1

module Matrix = struct

let transpose fill x-ll =
List.fold-right
(zip-with
 (fun y-o y-l-o ->
  Option.from fill y-o :: Option.from [] y-l-o))
[]
x-ll

end

let zip x0 y0 =
zip-with
(fun x-o y-o ->
 (Option.from x0 x-o, Option.from y0 y-o))

let get-grs-bbox gr-l =
List.fold-right
(fun gr ((x0, y0), (x1, y1)) ->
 (let ((gx0, gy0), (gx1, gy1)) = get-graphics-bbox gr in
  ((Length.min x0 gx0, Length.min y0 gy0), (Length.max x1 gx1, Length.max y1 gy1))))
((0pt, 0pt), (0pt, 0pt))
gr-l

% Calculate cell's boundary

let rc-face dir1 rc =
match (dir1, rc) with
| (Horizontal, ((x0, _), (x1, _))) -> (x0, x1)
| (Vertical, ((_, y0), (_, y1))) -> (y0, y1)

let pds-face dir1 pds =
match (dir1, pds) with
| (Horizontal, (pl, pr, _, _)) -> (pl, pr)
| (Vertical, (_, _, pt, pb)) -> (pb, pt)

let get-obj-bd dir1 cell =
match cell with
| Empty-raw -> (0pt, 0pt)
| Object-raw (gr, pds) ->
(let (z0, z1) = rc-face dir1 (get-graphics-bbox gr) in
 let (p0, p1) = pds-face dir1 pds in
 (z0 -' p0, z1 +' p1))
| Arrow-raw (cfg, dir, gr-l) ->
(match (dir1, dir) with
 | (Horizontal, (Vertical, _)) -> rc-face Horizontal (get-grs-bbox gr-l)
 | (Vertical, (Horizontal, _)) -> rc-face Vertical (get-grs-bbox gr-l)
 | _ -> (0pt, 0pt))

% bottom and top
let get-obj-bt cell = get-obj-bd Vertical cell

% left and right
let get-obj-lr cell = get-obj-bd Horizontal cell

let get-objs-boundary dir1 cell-l =
List.fold-right
(fun cell (x, y) ->
 (let (x1, y1) = get-obj-bd dir1 cell in
  (Length.min x x1, Length.max y y1)))
(0pt, 0pt)
cell-l

let get-objs-bt = get-objs-boundary Vertical

let get-objss-bts = List.map get-objs-bt

let get-objs-lr = get-objs-boundary Horizontal

let get-objss-lrs cell-ll = List.map get-objs-lr (Matrix.transpose Empty-raw cell-ll)

% Determine source and target of an arrow

% Find the first object in a list of cells
let find-object cx-l =
let-rec aux x-l y-l =
match y-l with
| [] -> (x-l, None, [])
| y :: y-l1 ->
(match y with
 | (Object-raw _, _) -> (x-l, Some y, y-l1)
 | _ -> aux (y :: x-l) y-l1)
in
aux [] cx-l

% Find the first virtical/horizontal arrow in a list of cells
let find-arrow dir1 cx-l0 obx cx-l =
let-rec aux x-l src y-l z-l =
match z-l with
| [] -> (x-l, src, y-l, None, [])
| z :: z-l1 ->
(match z with
 | (Object-raw _, _) -> aux (List.append y-l (src :: x-l)) z [] z-l1
 | (Arrow-raw (_, dir, _), _) ->
 (match (dir1, dir) with
  | (Horizontal, (Horizontal, _)) -> (x-l, src, y-l, Some z, z-l1)
  | (Vertical, (Vertical, _)) -> (x-l, src, y-l, Some z, z-l1)
  | _ -> aux x-l src (z :: y-l) z-l1)
 | _ -> aux x-l src (z :: y-l) z-l1)
in
aux cx-l0 obx [] cx-l

let find-varrow = find-arrow Vertical

let find-harrow = find-arrow Horizontal

% Adjust boundaries of cells

let d-sum z-l =
List.fold-right
(fun (_, ((x, y), _)) l ->
 l +' (y -' x))
0pt z-l

let bd-front dir1 bd =
match (dir1, bd) with
| (Horizontal, (_, r)) -> r
| (Vertical, (b, _)) -> b

let bd-back dir1 bd =
match (dir1, bd) with
| (Horizontal, (l, _)) -> l
| (Vertical, (_, t)) -> t

let make-qp-1-1 x-ls src y-ls arr z-ls tgt w-ls =
let (ar, (bd, fs)) = arr in
match ar with
| Arrow-raw (cfg, (dir1, _), gr-ls) -> (
  let (z0, z1) = rc-face dir1 (get-grs-bbox gr-ls) in
  let head = cfg#head-len in
  let tail = cfg#tail-len in
  let al = head +' tail +' (z1 -' z0) in
  let (b0, b1) = bd in
  let cl = b1 -' b0 in
  let yl = d-sum y-ls in
  let zl = d-sum z-ls in
  let (s, (sbd, _)) = src in
  let (t, (tbd, _)) = tgt in
  let sl = Length.abs (bd-front dir1 (get-obj-bd dir1 s) -' bd-front dir1 sbd) in
  let tl = Length.abs (bd-back dir1 (get-obj-bd dir1 t) -' bd-back dir1 tbd) in
  let d = al -' yl -' cl -' zl -' sl -' tl in
  if 0pt <' d then (
    let (tc, sc) =
    match dir1 with
    | Horizontal -> ((1.0, 0.0), (0.0, 1.0))
    | Vertical -> ((0.0, 1.0), (1.0, 0.0))
    in
    let f0 _ = (0.0, 0.0) in
    let f1 _ = (1.0, 1.0) in
    let cstr = List.(
      map f0 w-ls
      |> cons tc        % tgt
      |> reverse-append (map f1 z-ls)
      |> cons (1.0, 1.0)          % arr
      |> reverse-append (map f1 y-ls)
      |> cons sc        % src
      |> reverse-append (map f0 x-ls)
    ) in
    let (fsp, fsq) = fs in
    let dd = d *' 0.55 in
    (Some (cstr, d), (ar, (bd, (fsp +' dd, fsq +' dd))))
  ) else (None, arr)
)
| _ -> (None, arr)

let make-qp-1 dir1 cell-l (cstr-l, pq-l) =
let cpq-l = zip Empty-raw ((0pt, 0pt), (0pt, 0pt)) cell-l pq-l in
let (x-l, src, y-l) = find-object cpq-l in
match src with
| None -> (cstr-l, pq-l)
| Some src -> (
  let-rec aux cstr-l x-l src y-l = (
    let (x-l, src, y-l, arr, z-l) = find-arrow dir1 x-l src y-l in
    match arr with
    | None -> (cstr-l, List.(
      z-l
      |> reverse-append y-l
      |> cons src
      |> reverse-append x-l
    ))
    | Some arr -> (
      let (z-l, tgt, w-l) = find-object z-l in
      match tgt with
      | None -> (cstr-l, List.(
        w-l
        |> reverse-append z-l
        |> cons arr
        |> reverse-append y-l
        |> cons src
        |> reverse-append x-l
      ))
      | Some tgt -> (
        let (cstro, arr) = make-qp-1-1 x-l src y-l arr z-l tgt w-l in
        let cstr-l =
        match cstro with
        | None -> cstr-l
        | Some cstr -> cstr :: cstr-l
        in
        aux cstr-l List.(append z-l (arr :: append y-l (src :: x-l))) tgt w-l
      )
    )
  ) in
  let (cstr-l, cpq-l) = aux cstr-l x-l src y-l in
  (cstr-l, List.map Pair.snd cpq-l)
)

let make-qp dir1 cell-ll pq-l =
let pq-l1 = zip (0pt, 0pt) (0pt, 0pt) pq-l [] in
let (cstr-l, pq-l2) = List.fold-right (make-qp-1 dir1) ([], pq-l1) cell-ll in
(cstr-l, List.map Pair.snd pq-l2)

let-rec part-2 x-l =
match x-l with
| x :: y :: x-l1 -> (x, y) :: part-2 x-l1
| _ -> []

let len-to-f x = x /' 1pt
let f-to-len x = 1pt *' x

let solve-qp (cstr-l, pq-l) =
let f z-l = List.(concat (map (fun (x, y) -> [x; y]) z-l)) in
let ls = f pq-l in
let n = List.length ls in
let x = RealVector.of-list (List.map len-to-f ls) in
let (a1, b1) = List.unzip cstr-l in
let a2 = List.map (fun z-l -> RealVector.of-list (f z-l)) a1 in
let b2 = List.map len-to-f b1 in
let v = RealVector.of-list (List.append (List.repeat n 0.0) b2) in
let bs = RealVector.basis n in
let mx = RealMatrix.of-list n (List.append bs a2) in
let y = QP.solve mx v x in
part-2 (List.map f-to-len (RealVector.to-list y))

let bd-enlarge (p, q) (dp, dq) = (p -' dp, q +' dq)

let adjust-cellss-boundaries dir1 cell-ll pq-l =
let problem = make-qp dir1 cell-ll pq-l in
match problem with
| ([], _) -> pq-l
| _ -> (
  let pq-l1 = solve-qp problem in
  zip-with (fun pq-o1 pq-o2 -> (
    let pq1 = Option.from (0pt, 0pt) pq-o1 in
    let pq2 = Option.from (0pt, 0pt) pq-o2 in
    bd-enlarge pq1 pq2
  )) pq-l pq-l1
)

let adjust-cellss-bts cell-ll = adjust-cellss-boundaries Vertical (Matrix.transpose Empty-raw cell-ll)

let adjust-cellss-lrs = adjust-cellss-boundaries Horizontal

% Draw cells

let make-grid dir1 bd-l =
let (x-l, _) =
List.fold-right
(fun bd (x-l, x) ->
 (let x1 = x -' bd-front dir1 bd in
  (x1 :: x-l, x1 +' bd-back dir1 bd)))
([], 0pt)
bd-l in
x-l

let make-vgrid = make-grid Vertical

let make-hgrid = make-grid Horizontal

let draw-objects vgrid hgrid cell-ll =
let gr-lll =
zip-with
(fun y-o cell-l-o ->
 (let y = Option.from 0pt y-o in
  let cell-l = Option.from [] cell-l-o in
  zip-with
  (fun x-o cell-o ->
   (let x = Option.from 0pt x-o in
    let cell = Option.from Empty-raw cell-o in
    match cell with
    | Object-raw (gr, _) -> [shift-graphics (x, y) gr]
    | _ -> []))
  hgrid cell-l))
vgrid cell-ll in
List.concat (List.concat gr-lll)

let arrow-from-to-c dir1 dir2 z s-front t-back head tail =
let (from, to, t, h) =
(match dir2 with
 | Forwards -> (s-front, t-back, tail, 0pt -' head)
 | Backwards -> (t-back, s-front, 0pt -' tail, head))
in
match dir1 with
| Horizontal -> ((from, z), (to, z), (((from +' t) +' (to +' h)) *' 0.5, z))
| Vertical -> ((z, from), (z, to), (z, ((from -' t) +' (to -' h)) *' 0.5))

let draw-arrow dir1 z src arr tgt =
match arr with
| (Arrow-raw (cfg, dir, gr-l), _) ->
(match (dir1, dir) with
 | (Horizontal, (Vertical, _)) -> []
 | (Vertical, (Horizontal, _)) -> []
 | (_, (_, dir2)) ->
 (let (s, sc) = src in
  let (t, tc) = tgt in
  let s-front = sc +' bd-front dir1 (get-obj-bd dir1 s) in
  let t-back = tc +' bd-back dir1 (get-obj-bd dir1 t) in
  let (from, to, c) = arrow-from-to-c dir1 dir2 z s-front t-back cfg#head-len cfg#tail-len in
  let ga = cfg#draw from to in
  List.append ga (List.map (shift-graphics c) gr-l)))
| _ -> []

let draw-arrows dir1 vgrid hgrid cell-ll =
let gr-ll =
zip-with
(fun x-o cell-l-o ->
 (let x = Option.from 0pt x-o in
  let cell-l = Option.from [] cell-l-o in
  let cx-l = zip Empty-raw 0pt cell-l vgrid in
  let (_, src, y-l) = find-object cx-l in
  match src with
  | None -> []
  | Some src ->
  (let-rec aux src y-l =
   let (_, src, _, arr, z-l) = find-arrow dir1 [] src y-l in
   match arr with
   | None -> []
   | Some arr ->
   (let (_, tgt, w-l) = find-object z-l in
    match tgt with
    | None -> []
    | Some tgt ->
    (let gr-l = draw-arrow dir1 x src arr tgt in
     List.append gr-l (aux tgt w-l)))
   in
   aux src y-l)))
hgrid cell-ll in
List.concat gr-ll

let draw-varrows vgrid hgrid cell-ll = draw-arrows Vertical vgrid hgrid (Matrix.transpose Empty-raw cell-ll)

let draw-harrows vgrid hgrid = draw-arrows Horizontal hgrid vgrid

let draw-diagram cell-ll =
let bt-l0 = get-objss-bts cell-ll in
let bt-l = adjust-cellss-bts cell-ll bt-l0 in
let lr-l0 = get-objss-lrs cell-ll in
let lr-l = adjust-cellss-lrs cell-ll lr-l0 in
let vgrid = make-vgrid bt-l in
let hgrid = make-hgrid lr-l in
let obj-l = draw-objects vgrid hgrid cell-ll in
let varr-l = draw-varrows vgrid hgrid cell-ll in
let harr-l = draw-harrows vgrid hgrid cell-ll in
List.concat [obj-l; varr-l; harr-l]

let draw-solid-arrow ctx =
let color = get-text-color ctx in
Gr.arrow 0.5pt color 6pt 5pt 1.5pt

let draw-dashed-arrow ctx =
let color = get-text-color ctx in
Gr.dashed-arrow 0.5pt (3pt, 3pt, 0pt) color 6pt 5pt 1.5pt

let draw-eq ctx =
let color = get-text-color ctx in
fun from to ->
(let ((x0, y0), (x1, y1)) = (from, to) in
 let (x, y) = (x1 -' x0, y1 -' y0) in
 if Length.equal x 0pt && Length.equal y 0pt
 then
 []
 else
 let p = 1pt in
 let xf = x /' p in
 let yf = y /' p in
 let r = 1.0 /. RealVector.(norm (of-list [xf; yf])) in
 let d = p in
 let dx = 0pt -' d *' (yf *. r) in
 let dy = d *' (xf *. r) in
 let l1 = Gr.line (x0 +' dx, y0 +' dy) (x1 +' dx, y1 +' dy) in
 let l2 = Gr.line (x0 -' dx, y0 -' dy) (x1 -' dx, y1 -' dy) in
 List.map (stroke 0.5pt color) [l1; l2])

let arrow-config-default ctx = (|
  head-len = 10pt;
  tail-len = 6pt;
  draw = draw-solid-arrow ctx;
|)

% Commands

type arrow-style =
| ArrSolid
| ArrDashed
| ArrEqual

type object = (|
  label : inline-text;
  paddings : paddings;
|)

type arrow = (|
  direction : arrow-direction;
  style : arrow-style;
  left-label : inline-text option;
  right-label : inline-text option;
|)

type arrow-2 = (|
  label : inline-text option;
  paddings : paddings;
  direction : arrow-direction;
|)

type cell =
| Empty
| Object of object
| Arrow of arrow
| Arrow-2 of arrow-2

let left = (Horizontal, Backwards)
let right = (Horizontal, Forwards)
let up = (Vertical, Backwards)
let down = (Vertical, Forwards)

let solid = ArrSolid
let dashed = ArrDashed
let equal = ArrEqual

let empty = Empty

let object ?:pds-opt label =
Object (|
  label = label;
  paddings = Option.from (let pd = 3pt in (pd, pd, pd, pd)) pds-opt;
|)

let arrow ?:left-label ?: right-label ?:style-opt direction =
Arrow (|
  direction = direction;
  style = Option.from solid style-opt;
  left-label = left-label;
  right-label = right-label;
|)

let arrow-2 ?:label ?:pds-opt direction =
Arrow-2 (|
  label = label;
  paddings = Option.from (let (pdx, pdy) = (6pt, 3pt) in (pdx, pdx, pdy, pdy)) pds-opt;
  direction = direction;
|)

let eqarrow direction = arrow ?* ?* ?:(equal) direction

let label-context ctx = set-font-size (get-font-size ctx *' 0.75) ctx

let make-cell-raw ctx cell =
match cell with
| Empty -> Empty-raw
| Object obj ->
(let gr = draw-text (0pt, 0pt) (read-inline ctx obj#label) in
 let ((x0, y0), (x1, y1)) = get-graphics-bbox gr in
 let pds = obj#paddings in
 Object-raw (shift-graphics (0pt -' (x1 +' x0) *' 0.5, 0pt -' 4pt) gr, pds))
| Arrow arr ->
(let style = arr#style in
 let label-ctx = label-context ctx in
 let draw-label l = draw-text (0pt, 0pt) (read-inline label-ctx l) in
 let grl = Option.map draw-label arr#left-label in
 let grr = Option.map draw-label arr#right-label in
 let pd = 4pt in
 let shift-gr f gr =
 (let rc = get-graphics-bbox gr in
  shift-graphics (f rc) gr)
 in
 let dir = arr#direction in
 let (gr0, gr1) =
 (match dir with
  | (Horizontal, Forwards) ->
  (Option.map (shift-gr (fun ((x0, _), (x1, _)) -> ((0pt -' (x0 +' x1) *' 0.5), pd))) grl,
   Option.map (shift-gr (fun ((x0, _), (x1, y1)) -> ((0pt -' (x0 +' x1) *' 0.5), (0pt -' pd) -' y1))) grr)
  | (Horizontal, Backwards) ->
  (Option.map (shift-gr (fun ((x0, _), (x1, y1)) -> ((0pt -' (x0 +' x1) *' 0.5), (0pt -' pd) -' y1))) grl,
   Option.map (shift-gr (fun ((x0, _), (x1, _)) -> ((0pt -' (x0 +' x1) *' 0.5), pd))) grr)
  | (Vertical, Forwards) ->
  (Option.map (shift-gr (fun ((x0, y0), (_, y1)) -> (pd -' x0, 0pt -' (y0 +' y1) *' 0.5))) grl,
   Option.map (shift-gr (fun ((_, y0), (x1, y1)) -> ((0pt -' pd) -' x1, 0pt -' (y0 +' y1) *' 0.5))) grr)
  | (Vertical, Backwards) ->
  (Option.map (shift-gr (fun ((_, y0), (x1, y1)) -> ((0pt -' pd) -' x1, 0pt -' (y0 +' y1) *' 0.5))) grl,
   Option.map (shift-gr (fun ((x0, y0), (_, y1)) -> (pd -' x0, 0pt -' (y0 +' y1) *' 0.5))) grr))
 in
 Arrow-raw ((|
   (arrow-config-default ctx)
   with
   draw =
   (match style with
    | ArrSolid -> draw-solid-arrow ctx
    | ArrDashed -> draw-dashed-arrow ctx
    | ArrEqual -> draw-eq ctx);
 |), dir, List.concat [Option.to-list gr0; Option.to-list gr1]))
| Arrow-2 arr2 ->
(let m1 =
 (match arr2#direction with
  | (Horizontal, Backwards) -> ${\Leftarrow}
  | (Horizontal, Forwards) -> ${\Rightarrow}
  | (Vertical, Backwards) -> ${\Uparrow}
  | (Vertical, Forwards) -> ${\Downarrow})
 in
 let m =
 (match arr2#label with
  | None -> m1
  | Some l ->
  (let m2 = text-in-math MathOrd (fun ctx -> read-inline (label-context ctx) l) in
   match arr2#direction with
   | (Horizontal, _) -> math-upper m1 m2
   | (Vertical, _) -> ${\mathord{#m1} #m2}))
 in
 let gr = draw-text (0pt, 0pt) (embed-math ctx m) in
 let ((x0, y0), (x1, y1)) = get-graphics-bbox gr in
 let pds = arr2#paddings in
 Object-raw (shift-graphics (0pt -' (x1 +' x0) *' 0.5, 0pt -' 4pt) gr, pds))

let cd ctx cell-ll =
let gr-l = draw-diagram (List.map (List.map (make-cell-raw ctx)) cell-ll) in
let ((x0, y0), (x1, y1)) = get-grs-bbox gr-l in
let ym = (y0 +' y1) *' 0.5 -' 4pt in
let w = x1 -' x0 in
let h = y1 -' ym in
let d = ym -' y0 in
inline-graphics w h d
(fun (px, py) ->
 (List.map (shift-graphics (px -' x0, py -' ym)) gr-l))

let-block ctx +cd cell-ll =
line-break true true ctx (inline-fil ++ cd ctx cell-ll ++ inline-fil)

let-inline ctx \cd cell-ll =
inline-fil ++ embed-block-breakable ctx (read-block ctx '<+cd(cell-ll);>)

let-math \cd-m cell-ll =
text-in-math MathOrd (fun ctx -> cd ctx cell-ll)

let invert-direction-vertically dir =
match dir with
| (Vertical, Backwards) -> (Vertical, Forwards)
| (Vertical, Forwards) -> (Vertical, Backwards)
| _ -> dir

let invert-cell-vertically cell =
match cell with
| Arrow arr ->
(Arrow (|
  arr with
  left-label = arr#right-label;
  right-label = arr#left-label;
  direction = invert-direction-vertically arr#direction;
|))
| Arrow-2 arr-2 ->
(Arrow-2 (|
  arr-2 with
  direction = invert-direction-vertically arr-2#direction;
|))
| _ -> cell

let invert-v cell-ll = List.map (List.map invert-cell-vertically) (List.reverse cell-ll)

let transpose-direction dir =
match dir with
| (Horizontal, dir2) -> (Vertical, dir2)
| (Vertical, dir1) -> (Horizontal, dir1)

let transpose-cell cell =
match cell with
| Arrow arr ->
(Arrow (|
  arr with
  left-label = arr#right-label;
  right-label = arr#left-label;
  direction = transpose-direction arr#direction;
|))
| Arrow-2 arr-2 ->
(Arrow-2 (|
  arr-2 with
  direction = transpose-direction arr-2#direction;
|))
| _ -> cell

let transpose cell-ll = List.map (List.map transpose-cell) (Matrix.transpose empty cell-ll)

let invert-h cell-ll = transpose (invert-v (transpose cell-ll))

% The following are DEPRECATED. Will be removed in v1

let emp ctx = Empty-raw

let obj ctx it =
let gr = draw-text (0pt, 0pt) (read-inline ctx it) in
let ((x0, y0), (x1, y1)) = get-graphics-bbox gr in
let pd = 3pt in
let pds = (pd, pd, pd, pd) in
Object-raw (shift-graphics (0pt -' (x1 +' x0) *' 0.5, 0pt -' 4pt) gr, pds)

let arr ctx dir ?:style-opt l r =
let style = Option.from Solid style-opt in
let label-ctx = set-font-size (get-font-size ctx *' 0.75) ctx in
let grl = draw-text (0pt, 0pt) (read-inline label-ctx l) in
let grr = draw-text (0pt, 0pt) (read-inline label-ctx r) in
let ((lx0, ly0), (lx1, ly1)) = get-graphics-bbox grl in
let ((rx0, ry0), (rx1, ry1)) = get-graphics-bbox grr in
let pd = 4pt in
let (gr0, gr1) =
(match dir with
 | (Horizontal, Forwards) ->     % Right
 (shift-graphics ((0pt -' (lx0 +' lx1) *' 0.5), pd) grl,
  shift-graphics ((0pt -' (rx0 +' rx1) *' 0.5), (0pt -' pd) -' ry1) grr)
 | (Horizontal, Backwards) ->    % Left
 (shift-graphics ((0pt -' (lx0 +' lx1) *' 0.5), (0pt -' pd) -' ly1) grl,
  shift-graphics ((0pt -' (rx0 +' rx1) *' 0.5), pd) grr)
 | (Vertical, Forwards) ->       % Down
 (shift-graphics (pd -' lx0, 0pt -' (ly0 +' ly1) *' 0.5) grl,
  shift-graphics ((0pt -' pd) -' rx1, 0pt -' (ry0 +' ry1) *' 0.5) grr)
 | (Vertical, Backwards) ->      % Up
 (shift-graphics ((0pt -' pd) -' lx1, 0pt -' (ly0 +' ly1) *' 0.5) grl,
  shift-graphics (pd -' rx0, 0pt -' (ry0 +' ry1) *' 0.5) grr))
in
Arrow-raw ((|
  (arrow-config-default ctx)
  with
  draw = match style with
  | Solid -> draw-solid-arrow ctx
  | Dashed -> draw-dashed-arrow ctx;
|), dir, [gr0; gr1])

let larr ctx = arr ctx (Horizontal, Backwards)

let rarr ctx = arr ctx (Horizontal, Forwards)

let uarr ctx = arr ctx (Vertical, Backwards)

let darr ctx = arr ctx (Vertical, Forwards)

let harr = rarr

let varr = darr

let eqarr ctx dir =
Arrow-raw ((|
  (arrow-config-default ctx)
  with
  draw = draw-eq ctx;
|), dir, [])

let heq ctx = eqarr ctx (Horizontal, Forwards)
let veq ctx = eqarr ctx (Vertical, Forwards)

let arr2 ctx it =
let ib1 = embed-math ctx ${\Downarrow} in
let label-ctx = set-font-size (get-font-size ctx *' 0.75) ctx in
let ib2 = read-inline label-ctx it in
let gr = draw-text (0pt, 0pt) (ib1 ++ ib2) in
let ((x0, y0), (x1, y1)) = get-graphics-bbox gr in
let pdx = 6pt in
let pdy = 3pt in
let pds = (pdx, pdx, pdy, pdy) in
Object-raw (shift-graphics (0pt -' (x1 +' x0) *' 0.5, 0pt -' 4pt) gr, pds)

let diagram ctx cellssf =
let r = (|
  emp = emp ctx;
  obj = obj ctx;
  larr = larr ctx;
  rarr = rarr ctx;
  uarr = uarr ctx;
  darr = darr ctx;
  harr = harr ctx;
  varr = varr ctx;
  heq = heq ctx;
  veq = veq ctx;
  arr2 = arr2 ctx;
|) in
let cellss = cellssf r in
let grs = draw-diagram cellss in
let ((x0, y0), (x1, y1)) = get-grs-bbox grs in
let ym = (y0 +' y1) *' 0.5 -' 4pt in
let w = x1 -' x0 in
let h = y1 -' ym in
let d = ym -' y0 in
inline-graphics w h d
(fun (px, py) ->
 (List.map (shift-graphics (px -' x0, py -' ym)) grs))

let-block ctx +diagram cellssf =
line-break true true ctx (inline-fil ++ diagram ctx cellssf ++ inline-fil)

let-inline ctx \diagram cellssf =
inline-fil ++ embed-block-breakable ctx (read-block ctx '<+diagram(cellssf);>)

let-math \diagram-m cellssf =
text-in-math MathOrd (fun ctx -> diagram ctx cellssf)

end
