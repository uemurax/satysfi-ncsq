@require: base/list-ext
@require: base/option-ext

module NCSqUtil : sig

val zip-with : ('a option -> 'b option -> 'c) -> 'a list -> 'b list -> 'c list
val zip : 'a -> 'b -> 'a list -> 'b list -> ('a * 'b) list
val transpose : 'a -> ('a list) list -> ('a list) list

end = struct

let-rec zip-with f x-l y-l =
match (x-l, y-l) with
| ([], _) -> List.map (fun y -> (f None (Some y))) y-l
| (_, []) -> List.map (fun x -> (f (Some x) None)) x-l
| (x :: x-l1, y :: y-l1) -> f (Some x) (Some y) :: zip-with f x-l1 y-l1

let transpose fill x-ll =
List.fold-right
(zip-with
 (fun y-o y-l-o ->
  Option.from fill y-o :: Option.from [] y-l-o))
[]
x-ll

let zip x0 y0 =
zip-with
(fun x-o y-o ->
 (Option.from x0 x-o, Option.from y0 y-o))

end
