@require: base/tuple
@require: base/list-ext
@require: base/float
@import: ./matrix

module EQQP : sig

% `solve c a r` solves the equality-constrained quadratic programming
%     minimize (1/2)x^Tx + c^Tx
%     subject to a^Tx = 0
% using the R factor `r` of the matrix `a`.
% Retruns (x, l) where l is Lagrange multipliers.
val solve : RealVector.t -> RealMatrix.t -> UpperTriangle.t -> RealVector.t * RealVector.t

end = struct

let solve c a r =
let m = RealMatrix.app-t a c in
let l1 = LowerTriangle.app-inv (UpperTriangle.transpose r) m in
let lgr = UpperTriangle.app-inv r l1 in
let x = RealVector.(RealMatrix.app a lgr - c) in
(x, lgr)

end

module QP : sig

% `solve a b x0` solves a least squares problem
%     minimize (1/2)x^Tx
%     subject to a^Tx >= b
% from an initial feasible point x0
val solve : RealMatrix.t -> RealVector.t -> RealVector.t -> RealVector.t

val feasible : RealMatrix.t -> RealVector.t -> RealVector.t -> bool

end = struct

module ActiveSetMethod : sig

val solve : RealMatrix.t -> RealVector.t -> RealVector.t -> RealVector.t

end = struct

let remove k ls =
let-rec aux xs k ys =
match ys with
| [] -> (None, List.reverse xs)
| y :: ys -> (
  if k <= 0 then (Some y, List.(reverse-append xs ys))
  else aux (y :: xs) (k - 1) ys
)
in
aux [] k ls

% Remove an element of xs satisfying cond and minimizing fs < t.
% Return ((z, xo), ys) where xo is the minimizing fs, z is its value, and ys is xs from which xo is removed. Order is not preserved.
let remove-min t cond f xs =
let-rec aux (z, xo) xs ys =
match ys with
| y :: ys -> (
  if cond y then (
    let w = f y in
    if Float.(w < z) then (
      let xs1 =
      match xo with
      | None -> xs
      | Some x -> x :: xs
      in
      aux (w, Some y) xs1 ys
    ) else aux (z, xo) (y :: xs) ys
  ) else aux (z, xo) (y :: xs) ys
)
| _ -> ((z, xo), List.(reverse-append ys xs))
in
aux (t, None) [] xs

type state = (|
  working-set : (RealVector.t * float) list; % working set in the reverse order: the 0-th element is the right most column
  coworking-set : (RealVector.t * float) list;
  x : RealVector.t;
  working-qr : QR.t;
  dim : int;
|)

let-rec solve-1 state =
let wk0 = state#working-set in
let cwk0 = state#coworking-set in
let x0 = state#x in
let qr0 = state#working-qr in
let r0 = QR.r qr0 in
let dim = state#dim in
let aw0 = RealMatrix.of-list dim (List.reverse-map Pair.fst wk0) in
let (p, lgr) = EQQP.solve x0 aw0 r0 in
if RealVector.(x0 + p == x0)
then (
  let ko = RealVector.min lgr in
  match ko with
  | None -> x0
  | Some (i, l) -> (
    if Float.(l >= 0.0) then x0
    else (
      let k = RealVector.length lgr - i in
      let qr1 = QR.remove-column k qr0 in
      let (ao, wk1) = remove i wk0 in
      let cwk1 =
      match ao with
      | None -> cwk0
      | Some a -> a :: cwk0
      in
      solve-1 (|
        state with
        working-set = wk1;
        coworking-set = cwk1;
        working-qr = qr1;
      |)
    )
  )
)
else (
  let cond (xs, _) = Float.(RealVector.inner-product xs p < 0.0) in
  let f (xs, b) = (
    let s = RealVector.inner-product xs p in
    let t = RealVector.inner-product xs x0 in
    (1.0 /. s) *. (b -. t))
  in
  let ((alpha, ko), cwk1) = remove-min 1.0 cond f cwk0 in
  let x1 = RealVector.(x0 + alpha * p) in
  let (wk1, qr1) =
  match ko with
  | None -> (wk0, qr0)
  | Some k -> (k :: wk0, QR.append-column (Pair.fst k) qr0)
  in
  solve-1 (|
    state with
    working-set = wk1;
    coworking-set = cwk1;
    working-qr = qr1;
    x = x1;
  |)
)

let solve a b x =
let n = RealVector.length x in
let wk = [] in
let cwk = List.zip (RealMatrix.to-list a) (RealVector.to-list b) in
let qr = QR.nil n in
solve-1 (|
  working-set = wk;
  coworking-set = cwk;
  working-qr = qr;
  x = x;
  dim = n;
|)

end % ActiveSetMethod

let solve = ActiveSetMethod.solve

let feasible a b x =
let y = RealMatrix.(app-t a x) in
RealVector.(y >= b)

end % QP
