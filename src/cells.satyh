@require: base/list-ext
@import: ./base/point
@import: ./base/interval
@import: ./base/rect
@import: ./base/paddings
@import: ./arrows

module NCSqDirection : sig

type t

val h : t
val v : t
val elim : (|
  h : unit -> 'a;
  v : unit -> 'a;
|) -> t -> 'a

val flip : t -> t

end = struct

type t =
| Horizontal
| Vertical

let h = Horizontal
let v = Vertical

let elim x dir =
let f = (
  match dir with
  | Horizontal -> x#h
  | Vertical -> x#v
) in
f ()

let flip = elim (|
  h = fun _ -> v;
  v = fun _ -> h;
|)

end

module NCSqRect : sig

val face : NCSqDirection.t -> Rect.t -> Interval.t
val front : NCSqDirection.t -> Rect.t -> length
val back : NCSqDirection.t -> Rect.t -> length

end = struct

let face dir rc = NCSqDirection.elim (|
  h = fun _ -> Rect.interval-h rc;
  v = fun _ -> Rect.interval-v rc;
|) dir

let front dir rc = NCSqDirection.elim (|
  h = fun _ -> Rect.right rc;
  v = fun _ -> Rect.bottom rc;
|) dir

let back dir rc = NCSqDirection.elim (|
  h = fun _ -> Rect.left rc;
  v = fun _ -> Rect.top rc;
|) dir

end

module NCSqInterval : sig

val front : NCSqDirection.t -> Interval.t -> length
val back : NCSqDirection.t -> Interval.t -> length

end = struct

let front dir = NCSqDirection.elim (|
  h = fun _ -> Interval.right;
  v = fun _ -> Interval.left;
|) dir

let back dir = NCSqDirection.elim (|
  h = fun _ -> Interval.left;
  v = fun _ -> Interval.right;
|) dir

end

module NCSqObject : sig

type t

val of-graphics : Paddings.t -> graphics list -> t
val of-inline-text :
context ->
float * float * float * float -> % paddings, relative to font size
float ->                         % offset, relative to font size
inline-text -> t
val of-math : context -> float * float * float * float -> float -> math -> t

val bbox : t -> Rect.t
val draw : t -> graphics list

end = struct

type rect = Rect.t

type t = (|
  bbox : rect;
  draw : graphics list;
|)

let bbox obj = obj#bbox
let draw obj = obj#draw

let of-graphics pds gr-l =
let rc = List.(
  gr-l
  |> map get-graphics-bbox
  |> map Rect.of-rect
  |> fold-right Rect.union Rect.zero
) in (|
  bbox = Rect.pad pds rc;
  draw = gr-l;
|)

let of-inline-text ctx pds1 offset1 it =
let fs = get-font-size ctx in
let pds = Paddings.relative pds1 fs in
let offset = fs *' offset1 in
let gr1 = draw-text (0pt, 0pt) (read-inline ctx it) in
let rc = Rect.of-rect (get-graphics-bbox gr1) in
let itv = Rect.interval-h rc in
let c = Interval.center itv in
let gr2 = shift-graphics (Length.neg c, offset) gr1 in
of-graphics pds [gr2]

let of-math ctx pds offset m = of-inline-text ctx pds offset {${#m}}

end

module NCSqArrow : sig

type t

val of-style :
context ->
float * float ->              % paddings around labels, relative to font size
graphics list ->                % labels
NCSqArrowStyle.t ->
NCSqDirection.t -> t

val of-style-with-labels-gr :
context ->
graphics list ->                 % left label
graphics list ->                 % right label
float * float ->              % paddings (in, out)
NCSqArrowStyle.t ->
NCSqDirection.t -> t

val of-style-with-labels :
context ->
inline-text option ->                 % left label
inline-text option ->                 % right label
float * float ->              % paddings (in, out)
NCSqArrowStyle.t ->
NCSqDirection.t -> t

val of-style-with-mlabels :
context ->
math option ->                        % left label
math option ->                        % right label
float * float ->
NCSqArrowStyle.t ->
NCSqDirection.t -> t

val of-object : NCSqObject.t -> NCSqDirection.t -> t

val of-list : (NCSqDirection.t -> t) list -> NCSqDirection.t -> t

val direction : t -> NCSqDirection.t
val min-len : t -> length
val face : t -> Interval.t
val draw : length -> t -> graphics list

end = struct

type direction = NCSqDirection.t
type interval = Interval.t

type t = (|
  direction : direction;
  min-len : length;
  face : interval;
  draw : length -> graphics list;
|)

let direction arr = arr#direction
let min-len arr = arr#min-len
let face arr = arr#face
let draw len arr = arr#draw len

let of-style ctx (pdl, pdr) label-l style dir =
let fs = get-font-size ctx in
let rc = List.(
  label-l
  |> map get-graphics-bbox
  |> map Rect.of-rect
  |> fold-right Rect.union Rect.zero
) in
let s = NCSqArrowStyle.destruct style ctx in
let fc1 = NCSqRect.face (NCSqDirection.flip dir) rc in
let fc2 = NCSqRect.face dir rc in
let draw len = (
  let c2 = Interval.center fc2 in
  let c1 = Interval.(center (of-interval (s#tail-padding, len -' s#head-padding))) in
  let c = c1 -' c2 in
  NCSqDirection.elim (|
    h = fun _ -> (
      let gr-l1 = List.(
        label-l
        |> map (shift-graphics (c, 0pt))
      ) in
      let gr-l2 = s#draw Point.zero (Point.of-x len) in
      List.concat [gr-l1; gr-l2]
    );
    v = fun _ -> (
      let gr-l1 = List.(
        label-l
        |> map (shift-graphics (0pt, Length.neg c))
      ) in
      let gr-l2 = s#draw Point.zero (Point.of-y (Length.neg len)) in
      List.concat [gr-l1; gr-l2]
    );
  |) dir
) in
(|
  direction = dir;
  min-len = (
    Length.max (Interval.width fc2) s#body-length +'
    s#tail-padding +' s#head-padding
  );
  face = Interval.(
    fc1
    |> neg
    |> union s#body-itv
    |> expand (fs *' pdl) (fs *' pdr)
  );
  draw = draw;
|)

let of-style-with-labels-gr ctx grl-l grr-l pds style dir =
let fs = get-font-size ctx in
let (pdin, pdout) = pds in
let s = NCSqArrowStyle.destruct style ctx in
let pdin1 = fs *' pdin in
let itv = Interval.expand pdin1 pdin1 s#body-itv in
let left = Interval.left itv in
let right = Interval.right itv in
let rc gr-l = List.(
  gr-l
  |> map get-graphics-bbox
  |> map Rect.of-rect
  |> fold-right Rect.union Rect.zero
) in
let rcl = rc grl-l in
let rcr = rc grr-l in
let ct rc = Interval.center (NCSqRect.face dir rc) in
let cl = ct rcl in
let cr = ct rcr in
let fr rc = NCSqRect.front (NCSqDirection.flip dir) rc in
let bk rc = NCSqRect.back (NCSqDirection.flip dir) rc in
let (gr-l1, gr-l2) = NCSqDirection.elim (|
  h = fun _ -> (
    List.((map (shift-graphics Length.((neg cl, neg left -' fr rcl))) grl-l,
           map (shift-graphics Length.((neg cr, neg right -' bk rcr))) grr-l))
  );
  v = fun _ -> (
    List.((map (shift-graphics Length.((neg left -' bk rcl, neg cl))) grl-l,
           map (shift-graphics Length.((neg right -' fr rcr, neg cr))) grr-l))
  );
|) dir in
of-style ctx (pdout, pdout) (List.concat [gr-l1; gr-l2]) style dir

let of-style-with-labels ctx l-o r-o pds style dir =
let gr-l lbl-o = (
  Option.to-list lbl-o
  |> List.map (fun lbl -> draw-text (0pt, 0pt) (read-inline ctx lbl))
) in
let grl-l = gr-l l-o in
let grr-l = gr-l r-o in
of-style-with-labels-gr ctx grl-l grr-l pds style dir

let of-style-with-mlabels ctx l-o r-o pds style dir =
let f m = {${#m}} in
let l-o1 = Option.map f l-o in
let r-o1 = Option.map f r-o in
of-style-with-labels ctx l-o1 r-o1 pds style dir

let of-object obj dir =
let rc = NCSqObject.bbox obj in
let itv1 = NCSqRect.face (NCSqDirection.flip dir) rc in
let itv2 = NCSqRect.face dir rc in
let gr-l = NCSqObject.draw obj in
(|
  direction = dir;
  min-len = Interval.width itv2;
  face = Interval.neg itv1;
  draw = fun len -> (
    let l2 = len *' 0.5 in
    NCSqDirection.elim (|
      h = fun _ -> List.map (shift-graphics (l2, 0pt)) gr-l;
      v = fun _ -> List.map (shift-graphics (0pt, Length.neg l2)) gr-l;
    |) dir
  );
|)

let of-list arr-f-l dir =
let arr-l = List.map (fun arr-f -> arr-f dir) arr-f-l in
let-rec grid-aux (h, ls) arr-l = (
  match arr-l with
  | [] -> (
    let h2 = h *' 0.5 in
    (Interval.of-interval (Length.neg h2, h2),
     List.reverse-map (fun x -> x -' h2) ls)
  )
  | arr :: arr-l1 -> (
    let fc = face arr in
    let h1 = h -' Interval.left fc in
    let h2 = h1 +' Interval.right fc in
    grid-aux (h2, h1 :: ls) arr-l1
  )
) in
let (fc, grid) = grid-aux (0pt, []) arr-l in
(|
  direction = dir;
  min-len = List.(
    arr-l
    |> map min-len
    |> fold-right Length.max 0pt
  );
  face = fc;
  draw = fun len -> (
    let sh = NCSqDirection.elim (|
      h = fun _ y -> (0pt, Length.neg y);
      v = fun _ x -> (Length.neg x, 0pt);
    |) dir in
    List.(
      zip arr-l grid
      |> map (fun (arr, x) -> map (shift-graphics (sh x)) (draw len arr))
      |> concat
    )
  );
|)

end
