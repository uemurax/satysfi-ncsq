@require: base/list-ext
@import: ./base/rect
@import: ./base/paddings
@import: ./arrows

module NCSqDirection : sig

type t

val h : t
val v : t
val elim : (|
  h : unit -> 'a;
  v : unit -> 'a;
|) -> t -> 'a

end = struct

type t =
| Horizontal
| Vertical

let h = Horizontal
let v = Vertical

let elim x dir =
let f = (
  match dir with
  | Horizontal -> x#h
  | Vertical -> x#v
) in
f ()

end

module NCSqObject : sig

type t

val of-graphics : Paddings.t -> graphics list -> t
val of-inline-text : context -> Paddings.t -> length -> inline-text -> t
val of-math : context -> Paddings.t -> length -> math -> t

end = struct

type rect = Rect.t

type t = (|
  bbox : rect;
  draw : graphics list;
|)

let of-graphics pds gr-l =
let rc = List.(
  gr-l
  |> map get-graphics-bbox
  |> map Rect.of-rect
  |> fold-right Rect.union Rect.zero
) in (|
  bbox = Rect.pad pds rc;
  draw = gr-l;
|)

let of-inline-text ctx pds offset it =
let gr1 = draw-text (0pt, 0pt) (read-inline ctx it) in
let rc = Rect.of-rect (get-graphics-bbox gr1) in
let itv = Rect.interval-h rc in
let c = Interval.center itv in
let gr2 = shift-graphics (Length.neg c, offset) gr1 in
of-graphics pds [gr2]

let of-math ctx pds offset m = of-inline-text ctx pds offset {${#m}}

end

module NCSqArrow : sig

type t

val of-style :
context ->
NCSqDirection.t ->
float * float ->              % paddings around labels, relative to font size
graphics list ->                % labels
NCSqArrowStyle.t -> t

val of-style-with-labels-gr :
context ->
graphics list ->                 % left label
graphics list ->                 % right label
NCSqDirection.t ->
float * float ->              % paddings (in, out)
NCSqArrowStyle.t -> t

val of-style-with-labels :
context ->
inline-text ?->                 % left label
inline-text ?->                 % right label
NCSqDirection.t ->
float * float ->              % paddings (in, out)
NCSqArrowStyle.t -> t

val direction : t -> NCSqDirection.t
val min-len : t -> length
val face : t -> Interval.t
val draw : length -> t -> graphics list

end = struct

type direction = NCSqDirection.t
type interval = Interval.t

type t = (|
  direction : direction;
  min-len : length;
  face : interval;
  draw : length -> graphics list;
|)

let direction arr = arr#direction
let min-len arr = arr#min-len
let face arr = arr#face
let draw len arr = arr#draw len

let of-style ctx dir (pdl, pdr) label-l style =
let fs = get-font-size ctx in
let rc = List.(
  label-l
  |> map get-graphics-bbox
  |> map Rect.of-rect
  |> fold-right Rect.union Rect.zero
) in
let s = NCSqArrowStyle.destruct style ctx in
let ct fc2 len = (
  let c2 = Interval.center fc2 in
  let c1 = Interval.(center (of-interval (s#tail-padding, len -' s#head-padding))) in
  c1 -' c2
) in
let (fc1, fc2, draw) = NCSqDirection.elim (|
  h = fun _ -> (
    let fc1 = Rect.interval-v rc in
    let fc2 = Rect.interval-h rc in
    let draw len = (
      let gr-l1 = List.(
        label-l
        |> map (shift-graphics (ct fc2 len, 0pt))
      ) in
      let gr-l2 = s#draw (0pt, 0pt) (len, 0pt) in
      List.concat [gr-l1; gr-l2]
    ) in
    (fc1, fc2, draw)
  );
  v = fun _ -> (
    let fc1 = Rect.interval-h rc in
    let fc2 = Rect.interval-v rc in
    let draw len = (
      let gr-l1 = List.(
        label-l
        |> map (shift-graphics (0pt, Length.neg (ct fc2 len)))
      ) in
      let gr-l2 = s#draw (0pt, 0pt) (0pt, Length.neg len) in
      List.concat [gr-l1; gr-l2]
    ) in
    (fc1, fc2, draw)
  );
|) dir in
(|
  direction = dir;
  min-len = (
    Length.max (Interval.width fc2) s#body-length +'
    s#tail-padding +' s#head-padding
  );
  face = Interval.(
    fc1
    |> neg
    |> union (of-interval (s#body-left, s#body-right))
    |> expand (fs *' pdl) (fs *' pdr)
    |> neg
  );
  draw = draw;
|)

let of-style-with-labels-gr ctx grl-l grr-l dir pds style =
let fs = get-font-size ctx in
let (pdin, pdout) = pds in
let s = NCSqArrowStyle.destruct style ctx in
let left = s#body-left -' fs *' pdin in
let right = s#body-right +' fs *' pdin in
let rc gr-l = List.(
  gr-l
  |> map get-graphics-bbox
  |> map Rect.of-rect
  |> fold-right Rect.union Rect.zero
) in
let rcl = rc grl-l in
let rcr = rc grr-l in
let (gr-l1, gr-l2) = NCSqDirection.elim (|
  h = fun _ -> (
    let ct rc = Interval.center (Rect.interval-h rc) in
    let cl = ct rcl in
    let bl = Rect.bottom rcl in
    let cr = ct rcr in
    let tr = Rect.top rcr in
    List.((map (shift-graphics Length.((neg cl, neg left -' bl))) grl-l,
           map (shift-graphics Length.((neg cr, neg right -' tr))) grr-l))
  );
  v = fun _ -> (
    let ct rc = Interval.center (Rect.interval-v rc) in
    let cl = ct rcl in
    let rl = Rect.right rcl in
    let cr = ct rcr in
    let lr = Rect.left rcr in
    List.((map (shift-graphics Length.((neg left -' rl, neg cl))) grl-l,
           map (shift-graphics Length.((neg right -' lr, neg cr))) grr-l))
  );
|) dir in
of-style ctx dir (pdout, pdout) (List.concat [gr-l1; gr-l2]) style

let of-style-with-labels ctx ?:l-o ?:r-o dir pds style =
let gr-l lbl-o = (
  Option.to-list lbl-o
  |> List.map (fun lbl -> draw-text (0pt, 0pt) (read-inline ctx lbl))
) in
let grl-l = gr-l l-o in
let grr-l = gr-l r-o in
of-style-with-labels-gr ctx grl-l grr-l dir pds style

end
