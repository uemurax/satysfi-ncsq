@require: pervasives
@require: base/list-ext
@require: base/option-ext
@require: base/stream
@require: base/float
@require: debug-show-value/debug-show-value

module RealVector : sig

type t

val of-list : float list -> t
val to-list : t -> float list
val nil : t
val cons : float -> t -> t
val uncons : t -> float * t
val reverse : t -> t
val show : t -> string
val length : t -> int

val (+) : t -> t -> t
val (-) : t -> t -> t
val (*) : float -> t -> t

val norm : t -> float
val inner-product : t -> t -> float

% The standard basis in R^n
val basis : int -> t list
% zero vector of dimension n
val zero : int -> t

val rotate : float * float -> t * t -> t * t
val make-rotation : t * t -> (float * float) * (t * t)

end = struct

type t = float list

let of-list ls = ls
let to-list xs = xs
let nil = []
let cons v vs = v :: vs
let reverse = List.reverse
let show = DebugShowValue.(show-list show-float)
let length = List.length
let zero n = List.repeat n 0.0

let-rec basis n =
if n <= 0 then []
else (
  let m = n - 1 in
  let bs = basis m in
  let zs = List.repeat m 0.0 in
  let e = 1.0 :: zs in
  let cs = List.(map (cons 0.0) bs) in
  e :: cs
)

let uncons vs =
match vs with
| [] -> (0.0, [])
| x :: xs -> (x, xs)

let binop f xs ys = List.(map (fun (x, y) -> f x y) (zip xs ys))
let (+) = binop (+.)
let (-) = binop (-.)
let (*) x = List.map (fun y -> x *. y)

let norm xs =
let s = List.fold-right (fun x u -> Float.abs x +. u) 0.0 xs in
if Float.is-zero s then 0.0
else (
  let n1 = List.fold-right (fun x u -> (
    let y = x /. s in
    y *. y +. u
  )) 0.0 xs in
  s *. Float.sqrt n1
)

let inner-product xs ys = List.(fold-right (fun (x, y) v -> v +. x *. y) 0.0 (zip xs ys))

let rotate (c, s) (xs, ys) = (c * xs + s * ys, c * ys - s * xs)

let make-rotation (xs, ys) =
let (z, zs) = uncons xs in
let (w, ws) = uncons ys in
let n = norm (of-list [z; w]) in
let c = z /. n in
let s = w /. n in
let (u, v) = rotate (c, s) (zs, ws) in
((c, s), (n :: u, v))

end

module RealMatrix : sig

type t

val of-list : RealVector.t list -> t
val of-list-list : (float list) list -> t
val to-list : t -> RealVector.t list
val show : t -> string
val app : t -> RealVector.t -> RealVector.t
% a^T b
val app-t : t -> RealVector.t -> RealVector.t
% xs ys^T
val outer-product : RealVector.t -> RealVector.t -> t
val (-) : t -> t -> t
val nil : t
val cons-column : RealVector.t -> t -> t
val uncons-column : t -> RealVector.t * t
val cons-row : RealVector.t -> t -> t
val uncons-row : t -> (RealVector.t * t)
val id : int -> t
val comp : t -> t -> t
val transpose : t -> t

end = struct

type vector = RealVector.t
type t = vector list

let of-list ls = ls
let to-list mx = mx
let of-list-list lss = of-list (List.map RealVector.of-list lss)
let show = DebugShowValue.show-list RealVector.show
let id = RealVector.basis
let nil = List.nil
let cons-column = List.cons

let uncons-column mx =
match mx with
| [] -> (RealVector.nil, [])
| xs :: xss -> (xs, xss)

let app mx xs =
match mx with
| [] -> RealVector.nil
| (v :: _) -> (
  let n = RealVector.length v in
  List.(fold-right (fun (v, x) u -> RealVector.(u + x * v))
    (RealVector.zero n) (zip mx (RealVector.to-list xs))))

let app-t mx xs = RealVector.of-list List.(map (fun v -> RealVector.inner-product v xs) mx)

let comp xss yss = List.map (app xss) yss

let-rec zip-with f xs ys =
match (xs, ys) with
| ([], ys) -> List.map (fun y -> f None (Some y)) ys
| (xs, []) -> List.map (fun x -> f (Some x) None) xs
| (x :: xs, y :: ys) -> f (Some x) (Some y) :: zip-with f xs ys

let cons-row xs xss = zip-with (fun xo yso -> (
  let x = Option.from 0.0 xo in
  let ys = Option.from RealVector.nil yso in
  RealVector.cons x ys
)) (RealVector.to-list xs) xss

let uncons-row xss =
let (ls, lss) = List.(unzip (map RealVector.uncons xss)) in
(RealVector.of-list ls, lss)

let-rec transpose xss =
match xss with
| [] -> []
| xs :: xss -> cons-row xs (transpose xss)

let outer-product xs ys = of-list (List.map (fun y -> RealVector.(y * xs)) (RealVector.to-list ys))

let binop f xss yss = List.(map (fun (xs, ys) -> f xs ys) (zip xss yss))
let (-) = binop (fun xs ys -> RealVector.(xs - ys))

end

module LowerTriangle : sig

type t

val of-list : RealVector.t list -> t
val show : t -> string
val nil : t
% `prepend-column v vs lt` constructs the matrix
% | v  0  |
% | vs lt |
val prepend-column : float -> RealVector.t -> t -> t
val uncons-column : t -> RealVector.t * t
val app : t -> RealVector.t -> RealVector.t
% lt^-1 vs
val app-inv : t -> RealVector.t -> RealVector.t

end = struct

type vector = RealVector.t

% [v1; v2; ...; vn] represents the lower triangular matrix [v1; v2; ...; vn]
type t = vector list

let of-list ls = ls
let show = DebugShowValue.show-list RealVector.show
let nil = []
let prepend-column v vs lt = RealVector.cons v vs :: lt
let uncons-column lt =
match lt with
| [] -> (RealVector.nil, [])
| xs :: xss -> (xs, xss)

let-rec app lt vs =
match lt with
| [] -> RealVector.nil
| xs :: xss -> (
  let (y, ys) = RealVector.uncons xs in
  let (u, us) = RealVector.uncons vs in
  RealVector.(cons (u *. y) (u * ys + app xss us))
)

let-rec app-inv lt vs =
match lt with
| [] -> RealVector.nil
| xs :: xss -> (
  let (y, ys) = RealVector.uncons xs in
  let (u, us) = RealVector.uncons vs in
  let b = u /. y in
  let bs = RealVector.(us - b * ys) in
  RealVector.cons b (app-inv xss bs)
)

end

module UpperTriangle : sig

type t

val nil : t
% `append-column vs v ut` constructs the matrix
% | ut vs |
% | 0  v  |
val append-column : RealVector.t -> float -> t -> t
val remove-right-column : t -> t
val transpose : t -> LowerTriangle.t
val show : t -> string
val app : t -> RealVector.t -> RealVector.t
% ut^-1 vs
val app-inv : t -> RealVector.t -> RealVector.t
% mx^HR ut
val comp-rev-right : RealMatrix.t -> t -> RealMatrix.t

% split ut into
% | ut1 mx^HR^T |
% |     lt2^T   |
% where ut1 is a kxk upper triangular matrix and lt2 is a (n-k)x(n-k) lower triangular matrix
val split-at : int -> t -> t * RealMatrix.t * LowerTriangle.t

end = struct

type vector = RealVector.t

%  [v1; v2; ...; vn] represents the upper triangular matrix [vn^R; ...; v2^R; v1^R]
type t = vector list

let show = DebugShowValue.show-list RealVector.show
let nil = []
let append-column vs v ut = RealVector.(cons v (reverse vs)) :: ut
let remove-right-column vs =
match vs with
| [] -> []
| x :: xs -> xs

let transpose ut =
let-rec aux (acc1, acc2) ut =
match ut with
| [] -> acc1
| v :: vs -> (
  let s = Stream.(map (fun (x, xs) -> RealVector.cons x xs) (zip (of-list (RealVector.to-list v)) acc2)) in
  match Stream.uncons s with
  | None -> acc1
  | Some (h, t) -> (
    aux (h :: acc1, t) vs
  )
)
in
LowerTriangle.of-list (aux ([], Stream.const RealVector.nil) ut)

let app ut vs =
let-rec aux (acc1, acc2) ut vs =
match ut with
| [] -> acc1
| xs :: xss -> (
  let (u, us) = RealVector.uncons vs in
  let s = Stream.(map (fun (x, y) -> y +. u *. x) (zip (of-list (RealVector.to-list xs)) acc2)) in
  match Stream.uncons s with
  | None -> acc1
  | Some (h, t) -> (
    aux (RealVector.cons h acc1, t) xss us
  )
)
in
aux (RealVector.nil, Stream.const 0.0) ut (RealVector.reverse vs)

let app-inv ut vs =
let-rec aux acc ut vs =
match ut with
| [] -> acc
| xs :: xss -> (
  let (y, ys) = RealVector.uncons xs in
  let (u, us) = RealVector.uncons vs in
  let b = u /. y in
  let bs = RealVector.(us - b * ys) in
  aux (RealVector.cons b acc) xss bs
)
in
aux RealVector.nil ut (RealVector.reverse vs)

let comp-rev-right mx ut =
let-rec aux acc mx ut =
match ut with
| [] -> acc
| xs :: xss -> (
  let zs = RealMatrix.app mx xs in
  let (_, yss) = RealMatrix.uncons-column mx in
  aux (RealMatrix.cons-column zs acc) yss xss
)
in
aux RealMatrix.nil mx ut

let split-1 ut =
match ut with
| [] -> ([], RealVector.nil, 0.0)
| xs :: xss -> (
  let (y, ys) = RealVector.uncons xs in
  (xss, ys, y)
)

let split-at k ut =
let-rec aux (acc1, acc2) i ut =
if i <= 0 then (ut, acc1, acc2)
else (
  let (xss, ys, y) = split-1 ut in
  let (zs, zss) = RealMatrix.uncons-column acc1 in
  aux (RealMatrix.cons-row ys zss, LowerTriangle.prepend-column y zs acc2) (i - 1) xss
) in
let n = List.length ut in
let i = n - k in
aux (RealMatrix.nil, LowerTriangle.nil) i ut

end

module Householder : sig

type t

% Calculate a pair (h, r) where h is a Householder transformation such that h x = r e1.
val generate : RealVector.t -> t * float

val show : t -> string
val to-vector : t -> RealVector.t
val app : t -> RealVector.t -> RealVector.t
val comp-right : RealMatrix.t -> t -> RealMatrix.t

end = struct

type vector = RealVector.t
type t = vector

let show = RealVector.show
let to-vector u = u

let sqrt2 = Float.sqrt 2.0

let generate xs =
let n = RealVector.norm xs in
if Float.is-zero n then (
  let (_, ys) = RealVector.uncons xs in
  (RealVector.cons sqrt2 ys, 0.0)
) else (
  let u1 = RealVector.((1.0 /. n) * xs) in
  let (y, ys) = RealVector.uncons u1 in
  let (z, r) = if Float.(y >= 0.0) then (y +. 1.0, Float.neg n)
  else (y -. 1.0, n)
  in
  let w = Float.(sqrt (abs z)) in
  let u = RealVector.cons z ys in
  (RealVector.((1.0 /. w) * u), r)
)

let app h vs =
let s = RealVector.inner-product h vs in
let u = RealVector.(s * h) in
RealVector.(vs - u)

let comp-right mx h =
let u1 = RealMatrix.app mx h in
let u2 = RealMatrix.outer-product u1 h in
RealMatrix.(mx - u2)

end

module QR : sig

type t

% QR decomposition of n x 0 matrix
val nil : int -> t

% If qr is a QR factorization of mx, `append-column qr v` constructs a QR factorization of [mx v].
val append-column : RealVector.t -> t -> t
% If qr is a QR factorization of mx, `remove-column k qr` constructs a QR factorization of mx removed the k-th column.
val remove-column : int -> t -> t

% Q and R factors
val r : t -> UpperTriangle.t
val q : t -> RealMatrix.t

val compose : t -> RealMatrix.t

end = struct

type vector = RealVector.t
type matrix = RealMatrix.t
type upper-tri = UpperTriangle.t
% ((Q1, Q2), R), but Q1 is stored in the reverse direction
type t = (vector list * vector list) * upper-tri

let r (_, ut) = ut
let q ((q1, q2), _) =
let-rec aux xs ys =
match xs with
| [] -> ys
| x :: xs -> aux xs (x :: ys)
in
RealMatrix.of-list (aux q1 q2)

let nil n = (([], RealVector.basis n), UpperTriangle.nil)

let append-column xs ((q1, q2), r) =
let m1 = (RealMatrix.of-list (List.reverse q1)) in
let ys = RealMatrix.app-t m1 xs in
let m2 = (RealMatrix.of-list q2) in
let zs = RealMatrix.app-t m2 xs in
let (h, rho) = Householder.generate zs in
let m3 = Householder.comp-right m2 h in
let (u, m) = RealMatrix.uncons-column m3 in
((u :: q1, RealMatrix.to-list m), UpperTriangle.append-column ys rho r)

let compose ((q1, _), r) = UpperTriangle.comp-rev-right (RealMatrix.of-list q1) r

let ls-split-at i ls =
let-rec aux acc i ls =
if i <= 0 then (acc, ls)
else (
  match ls with
  | [] -> (acc, [])
  | x :: xs -> aux (x :: acc) (i - 1) xs
) in
aux [] i ls

let remove-column k ((q1, q2), r) =
let n = List.length q1 in
let i = n - (k + 1) in
let (q11, q12) = ls-split-at i q1 in
let (r1, mx, lt) = UpperTriangle.split-at (k + 1) r in
let ut = UpperTriangle.remove-right-column r1 in
let-rec aux (qs1, qs2) (ut, mx, lt) = (
  match (qs1, qs2) with
  | (q1 :: qs1, q2 :: qs2) -> (
    let (xs, xss) = RealMatrix.uncons-column mx in
    let (ys, yss) = LowerTriangle.uncons-column lt in
    let ((c, s), (zs, ws)) = RealVector.make-rotation (xs, ys) in
    let (v, m1) = RealMatrix.uncons-row xss in
    let (u, us) = RealVector.uncons zs in
    let m2 = RealMatrix.cons-column us m1 in
    let ut1 = UpperTriangle.append-column v u ut in
    let (qq2, qq1) = RealVector.rotate (c, s) (q2, q1) in
    aux (qs1, qq2 :: qq1 :: qs2) (ut1, m2, yss))
  | _ -> (qs2, ut)
) in
let (q1, r) = aux (q11, q12) (ut, mx, lt) in
((q1, q2), r)

end
