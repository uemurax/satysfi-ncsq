@require: pervasives
@require: base/list-ext
@require: base/option-ext
@require: base/stream
@require: base/float
@require: debug-show-value/debug-show-value

module RealVector : sig

type t

val of-list : float list -> t
val to-list : t -> float list
val nil : t
val cons : float -> t -> t
val uncons : t -> float * t
val reverse : t -> t
val show : t -> string

val (+) : t -> t -> t
val (-) : t -> t -> t
val (*) : float -> t -> t

val norm : t -> float
val inner-product : t -> t -> float

end = struct

type t = float list

let of-list ls = ls
let to-list xs = xs
let nil = []
let cons v vs = v :: vs
let reverse = List.reverse
let show = DebugShowValue.(show-list show-float)

let uncons vs =
match vs with
| [] -> (0.0, [])
| x :: xs -> (x, xs)

let binop f xs ys = List.(map (fun (x, y) -> f x y) (zip xs ys))
let (+) = binop (+.)
let (-) = binop (-.)
let (*) x = List.map (fun y -> x *. y)

let norm xs =
let s = List.fold-right (fun x u -> Float.abs x +. u) 0.0 xs in
if Float.is-zero s then 0.0
else (
  let n1 = List.fold-right (fun x u -> (
    let y = x /. s in
    y *. y +. u
  )) 0.0 xs in
  s *. Float.sqrt n1
)

let inner-product xs ys = List.(fold-right (fun (x, y) v -> v +. x *. y) 0.0 (zip xs ys))

end

module LowerTriangle : sig

type t

val of-list : RealVector.t list -> t
val show : t -> string
val nil : t
% `prepend-column v vs lt` constructs the matrix
% | v  0  |
% | vs lt |
val prepend-column : float -> RealVector.t -> t -> t
val app : t -> RealVector.t -> RealVector.t
% lt^-1 vs
val app-inv : t -> RealVector.t -> RealVector.t

end = struct

type vector = RealVector.t

% [v1; v2; ...; vn] represents the lower triangular matrix [v1; v2; ...; vn]
type t = vector list

let of-list ls = ls
let show = DebugShowValue.show-list RealVector.show
let nil = []
let prepend-column v vs lt = RealVector.cons v vs :: lt

let-rec app lt vs =
match lt with
| [] -> RealVector.nil
| xs :: xss -> (
  let (y, ys) = RealVector.uncons xs in
  let (u, us) = RealVector.uncons vs in
  RealVector.(cons (u *. y) (u * ys + app xss us))
)

let-rec app-inv lt vs =
match lt with
| [] -> RealVector.nil
| xs :: xss -> (
  let (y, ys) = RealVector.uncons xs in
  let (u, us) = RealVector.uncons vs in
  let b = u /. y in
  let bs = RealVector.(us - b * ys) in
  RealVector.cons b (app-inv xss bs)
)

end

module UpperTriangle : sig

type t

val nil : t
% `append-column ut vs v` constructs the matrix
% | ut vs |
% | 0  v  |
val append-column : t -> RealVector.t -> float -> t
val transpose : t -> LowerTriangle.t
val show : t -> string
val app : t -> RealVector.t -> RealVector.t
% ut^-1 vs
val app-inv : t -> RealVector.t -> RealVector.t

end = struct

type vector = RealVector.t

%  [v1; v2; ...; vn] represents the upper triangular matrix [vn^R; ...; v2^R; v1^R]
type t = vector list

let show = DebugShowValue.show-list RealVector.show
let nil = []
let append-column ut vs v = RealVector.(cons v (reverse vs)) :: ut

let transpose ut =
let-rec aux (acc1, acc2) ut =
match ut with
| [] -> acc1
| v :: vs -> (
  let s = Stream.(map (fun (x, xs) -> RealVector.cons x xs) (zip (of-list (RealVector.to-list v)) acc2)) in
  match Stream.uncons s with
  | None -> acc1
  | Some (h, t) -> (
    aux (h :: acc1, t) vs
  )
)
in
LowerTriangle.of-list (aux ([], Stream.const RealVector.nil) ut)

let app ut vs =
let-rec aux (acc1, acc2) ut vs =
match ut with
| [] -> acc1
| xs :: xss -> (
  let (u, us) = RealVector.uncons vs in
  let s = Stream.(map (fun (x, y) -> y +. u *. x) (zip (of-list (RealVector.to-list xs)) acc2)) in
  match Stream.uncons s with
  | None -> acc1
  | Some (h, t) -> (
    aux (RealVector.cons h acc1, t) xss us
  )
)
in
aux (RealVector.nil, Stream.const 0.0) ut (RealVector.reverse vs)

let app-inv ut vs =
let-rec aux acc ut vs =
match ut with
| [] -> acc
| xs :: xss -> (
  let (y, ys) = RealVector.uncons xs in
  let (u, us) = RealVector.uncons vs in
  let b = u /. y in
  let bs = RealVector.(us - b * ys) in
  aux (RealVector.cons b acc) xss bs
)
in
aux RealVector.nil ut (RealVector.reverse vs)

end

module Householder : sig

type t

% Calculate a pair (h, r) where h is a Householder transformation such that h x = r e1.
val generate : RealVector.t -> t * float

val to-vector : t -> RealVector.t
val app : t -> RealVector.t -> RealVector.t

end = struct

type vector = RealVector.t
type t = vector

let to-vector u = u

let sqrt2 = Float.sqrt 2.0

let generate xs =
let n = RealVector.norm xs in
if Float.is-zero n then (
  let (_, ys) = RealVector.uncons xs in
  (RealVector.cons sqrt2 ys, 0.0)
) else (
  let u1 = RealVector.((1.0 /. n) * xs) in
  let (y, ys) = RealVector.uncons u1 in
  let (z, r) = if Float.(y >= 0.0) then (y +. 1.0, Float.neg n)
  else (y -. 1.0, n)
  in
  let w = Float.(sqrt (abs z)) in
  let u = RealVector.cons z ys in
  (RealVector.((1.0 /. w) * u), r)
)

let app h vs =
let s = RealVector.inner-product h vs in
let u = RealVector.(s * h) in
RealVector.(vs - u)

end
