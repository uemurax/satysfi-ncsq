@require: pervasives
@require: list
@require: base/tuple
@require: base/length
@require: option
@require: gr
@require: math

module NCSq : sig

type cell

val \diagram : [(|
  emp : cell;
  obj : inline-text -> cell;
  larr : inline-text -> inline-text -> cell;
  rarr : inline-text -> inline-text -> cell;
  uarr : inline-text -> inline-text -> cell;
  darr : inline-text -> inline-text -> cell;
  heq : cell;
  veq : cell;
  arr2 : inline-text -> cell;
  harr : inline-text -> inline-text -> cell;
  varr : inline-text -> inline-text -> cell;
|) -> (cell list) list] inline-cmd

val +diagram : [(|
  emp : cell;
  obj : inline-text -> cell;
  larr : inline-text -> inline-text -> cell;
  rarr : inline-text -> inline-text -> cell;
  uarr : inline-text -> inline-text -> cell;
  darr : inline-text -> inline-text -> cell;
  heq : cell;
  veq : cell;
  arr2 : inline-text -> cell;
  harr : inline-text -> inline-text -> cell;
  varr : inline-text -> inline-text -> cell;
|) -> (cell list) list] block-cmd

val \diagram-m : [(|
  emp : cell;
  obj : inline-text -> cell;
  larr : inline-text -> inline-text -> cell;
  rarr : inline-text -> inline-text -> cell;
  uarr : inline-text -> inline-text -> cell;
  darr : inline-text -> inline-text -> cell;
  heq : cell;
  veq : cell;
  arr2 : inline-text -> cell;
  harr : inline-text -> inline-text -> cell;
  varr : inline-text -> inline-text -> cell;
|) -> (cell list) list] math-cmd

end = struct

type direction1 =
| Horizontal
| Vertical

type direction2 =
| Forwards
| Backwards

type direction = direction1 * direction2

type arrow-config = (|
  head-len : length;
  tail-len : length;
  draw : point -> point -> graphics list;
|)

type paddings = length * length * length * length

type cell =
| Empty
| Object of graphics * paddings
| Arrow of arrow-config * direction * graphics list

% Utilities

let-rec zip-with f xs ys =
match (xs, ys) with
| ([], _) -> List.map (fun y -> (f None (Some y))) ys
| (_, []) -> List.map (fun x -> (f (Some x) None)) xs
| (x :: xs, y :: ys) -> f (Some x) (Some y) :: zip-with f xs ys

let transpose fill xss =
List.fold-right
(zip-with
 (fun y ys ->
  Option.from fill y :: Option.from [] ys))
[]
xss

let zip x0 y0 =
zip-with
(fun x y ->
 (Option.from x0 x, Option.from y0 y))

let get-grs-bbox grs =
List.fold-right
(fun gr ((x0, y0), (x1, y1)) ->
 (let ((gx0, gy0), (gx1, gy1)) = get-graphics-bbox gr in
  ((Length.min x0 gx0, Length.min y0 gy0), (Length.max x1 gx1, Length.max y1 gy1))))
((0pt, 0pt), (0pt, 0pt))
grs

% Calculate cell's boundary

let rc-face dir1 rc =
match (dir1, rc) with
| (Horizontal, ((x0, _), (x1, _))) -> (x0, x1)
| (Vertical, ((_, y0), (_, y1))) -> (y0, y1)

let pds-face dir1 pds =
match (dir1, pds) with
| (Horizontal, (pl, pr, _, _)) -> (pl, pr)
| (Vertical, (_, _, pt, pb)) -> (pt, pb)

let get-obj-bd dir1 cell =
match cell with
| Empty -> (0pt, 0pt)
| Object (gr, pds) ->
(let (z0, z1) = rc-face dir1 (get-graphics-bbox gr) in
 let (p0, p1) = pds-face dir1 pds in
 (z0 -' p0, z1 +' p1))
| Arrow (cfg, dir, grs) ->
(match (dir1, dir) with
 | (Horizontal, (Vertical, _)) -> rc-face Horizontal (get-grs-bbox grs)
 | (Vertical, (Horizontal, _)) -> rc-face Vertical (get-grs-bbox grs)
 | _ -> (0pt, 0pt))

% bottom and top
let get-obj-bt cell = get-obj-bd Vertical cell

% left and right
let get-obj-lr cell = get-obj-bd Horizontal cell

let get-objs-boundary dir1 cells =
List.fold-right
(fun cell (x, y) ->
 (let (x1, y1) = get-obj-bd dir1 cell in
  (Length.min x x1, Length.max y y1)))
(0pt, 0pt)
cells

let get-objs-bt = get-objs-boundary Vertical

let get-objss-bts cellss = List.map get-objs-bt cellss

let get-objs-lr = get-objs-boundary Horizontal

let get-objss-lrs cellss = List.map get-objs-lr (transpose Empty cellss)

% Determine source and target of an arrow

% Find the first object in a list of cells
let find-object cxs =
let-rec aux xs ys =
match ys with
| [] -> (xs, None, [])
| y :: ys ->
(match y with
 | (Object _, _) -> (xs, Some y, ys)
 | _ -> aux (y :: xs) ys)
in
aux [] cxs

% Find the first virtical/horizontal arrow in a list of cells
let find-arrow dir1 cxs0 obx cxs =
let-rec aux xs src ys zs =
match zs with
| [] -> (xs, src, ys, None, [])
| z :: zs ->
(match z with
 | (Object _, _) -> aux (List.append ys (src :: xs)) z [] zs
 | (Arrow (_, dir, _), _) ->
 (match (dir1, dir) with
  | (Horizontal, (Horizontal, _)) -> (xs, src, ys, Some z, zs)
  | (Vertical, (Vertical, _)) -> (xs, src, ys, Some z, zs)
  | _ -> aux xs src (z :: ys) zs)
 | _ -> aux xs src (z :: ys) zs)
in
aux cxs0 obx [] cxs

let find-varrow cxs0 obx cxs = find-arrow Vertical cxs0 obx cxs

let find-harrow cxs0 obx cxs = find-arrow Horizontal cxs0 obx cxs

% Adjust boundaries of cells

let d-sum zs =
List.fold-right
(fun (_, (x, y)) l ->
 l +' (y -' x))
0pt zs

let bd-front dir1 bd =
match (dir1, bd) with
| (Horizontal, (_, r)) -> r
| (Vertical, (b, _)) -> b

let bd-back dir1 bd =
match (dir1, bd) with
| (Horizontal, (l, _)) -> l
| (Vertical, (_, t)) -> t

let update-boundaries src xs arr ys tgt =
match arr with
| (Arrow (cfg, (dir1, _), grs), bd) ->
let (z0, z1) = rc-face dir1 (get-grs-bbox grs) in
let head = cfg#head-len in
let tail = cfg#tail-len in
let al = head +' tail +' (z1 -' z0) in
let (b0, b1) = bd in
let cl = b1 -' b0 in
let xl = d-sum xs in
let yl = d-sum ys in
let (s, sbd) = src in
let (t, tbd) = tgt in
let sl = Length.abs (bd-front dir1 (get-obj-bd dir1 s) -' bd-front dir1 sbd) in
let tl = Length.abs (bd-back dir1 (get-obj-bd dir1 t) -' bd-back dir1 tbd) in
let l = al -' (xl +' cl +' yl +' sl +' tl) in
if 0pt <' l then
(let n = List.length xs + 1 + List.length ys in
 let dl = l *' (0.5 /. (float n)) in
 let f (z, (p, q)) = (z, (p -' dl, q +' dl)) in
 (List.map f xs, f arr, List.map f ys))
else
(xs, arr, ys)
| _ -> (xs, arr, ys)

let adjust-cells-boundaries dir1 cells pqs =
let cpqs = zip Empty (0pt, 0pt) cells pqs in
let (xs, src, ys) = find-object cpqs in
match src with
| None -> pqs
| Some src ->
(let-rec aux xs src ys =
 let (xs, src, ys, arr, zs) = find-arrow dir1 xs src ys in
 match arr with
 | None -> List.reverse (List.append ys (src :: xs)) % zs must be []
 | Some arr ->
 (let (zs, tgt, ws) = find-object zs in
  match tgt with
  | None -> List.reverse (List.append zs (arr :: List.append ys (src :: xs))) % ws must be []
  | Some tgt ->
  (let (ys1, arr1, zs1) = update-boundaries src ys arr zs tgt in
   aux (List.append zs1 (arr1 :: List.append ys1 (src :: xs))) tgt ws))
 in
 let cpqs1 = aux xs src ys in
 List.map Pair.snd cpqs1)

let adjust-cells-bts = adjust-cells-boundaries Vertical

let adjust-cellss-bts cellss bts =
List.fold-right adjust-cells-bts bts (transpose Empty cellss)

let adjust-cells-lrs = adjust-cells-boundaries Horizontal

let adjust-cellss-lrs cellss lrs =
List.fold-right adjust-cells-lrs lrs cellss

% Draw cells

let make-grid dir1 bds =
let (bd-front, bd-back) =
match dir1 with
| Horizontal ->
(let bd-front (_, r) = r in
 let bd-back (l, _) = l in
 (bd-front, bd-back))
| Vertical ->
(let bd-front (b, _) = b in
 let bd-back (_, t) = t in
 (bd-front, bd-back))
in
let (ls, _) =
List.fold-right
(fun bd (ls, l) ->
 (let l1 = l -' bd-front bd in
  (l1 :: ls, l1 +' bd-back bd)))
([], 0pt)
bds in
ls

let make-vgrid bts = make-grid Vertical bts

let make-hgrid lrs = make-grid Horizontal lrs

let draw-objects vgrid hgrid cellss =
let grsss =
zip-with
(fun y cells ->
 (let y = Option.from 0pt y in
  let cells = Option.from [] cells in
  zip-with
  (fun x cell ->
   (let x = Option.from 0pt x in
    let cell = Option.from Empty cell in
    match cell with
    | Object (gr, _) -> [shift-graphics (x, y) gr]
    | _ -> []))
  hgrid cells))
vgrid cellss in
List.concat (List.concat grsss)

let arrow-from-to dir1 dir2 z s-front t-back =
let (from, to) =
(match dir2 with
 | Forwards -> (s-front, t-back)
 | Backwards -> (t-back, s-front))
in
match dir1 with
| Horizontal -> ((from, z), (to, z))
| Vertical -> ((z, from), (z, to))

let draw-arrow dir1 z src arr tgt =
match arr with
| (Arrow (cfg, dir, grs), _) ->
(match (dir1, dir) with
 | (Horizontal, (Vertical, _)) -> []
 | (Vertical, (Horizontal, _)) -> []
 | (_, (_, dir2)) ->
 (let (s, sc) = src in
  let (t, tc) = tgt in
  let s-front = sc +' bd-front dir1 (get-obj-bd dir1 s) in
  let t-back = tc +' bd-back dir1 (get-obj-bd dir1 t) in
  let (from, to) = arrow-from-to dir1 dir2 z s-front t-back in
  let ga = cfg#draw from to in
  let ((ax0, ay0), (ax1, ay1)) = (from, to) in
  let ax = (ax0 +' ax1) *' 0.5 in
  let ay = (ay0 +' ay1) *' 0.5 in
  List.append ga (List.map (shift-graphics (ax, ay)) grs)))
| _ -> []

let draw-arrows dir1 vgrid hgrid cellss =
let grss =
zip-with
(fun x cells ->
 (let x = Option.from 0pt x in
  let cells = Option.from [] cells in
  let cxs = zip Empty 0pt cells vgrid in
  let (_, src, ys) = find-object cxs in
  match src with
  | None -> []
  | Some src ->
  (let-rec aux src ys =
   let (_, src, _, arr, zs) = find-arrow dir1 [] src ys in
   match arr with
   | None -> []
   | Some arr ->
   (let (_, tgt, ws) = find-object zs in
    match tgt with
    | None -> []
    | Some tgt ->
    (let grs = draw-arrow dir1 x src arr tgt in
     List.append grs (aux tgt ws)))
   in
   aux src ys)))
hgrid cellss in
List.concat grss

let draw-varrows vgrid hgrid cellss = draw-arrows Vertical vgrid hgrid (transpose Empty cellss)

let draw-harrows vgrid hgrid cellss = draw-arrows Horizontal hgrid vgrid cellss

let draw-diagram cellss =
let bts0 = get-objss-bts cellss in
let bts = adjust-cellss-bts cellss bts0 in
let lrs0 = get-objss-lrs cellss in
let lrs = adjust-cellss-lrs cellss lrs0 in
let vgrid = make-vgrid bts in
let hgrid = make-hgrid lrs in
let objs = draw-objects vgrid hgrid cellss in
let varrs = draw-varrows vgrid hgrid cellss in
let harrs = draw-harrows vgrid hgrid cellss in
List.concat [objs; varrs; harrs]

let emp ctx = Empty

let obj ctx it =
let gr = draw-text (0pt, 0pt) (read-inline ctx it) in
let ((x0, y0), (x1, y1)) = get-graphics-bbox gr in
let pd = 3pt in
let pds = (pd, pd, pd, pd) in
Object (shift-graphics (0pt -' (x1 +' x0) *' 0.5, 0pt -' 4pt) gr, pds)

let arrow-config-default ctx = (|
  head-len = 8pt;
  tail-len = 8pt;
  draw =
  (let color = get-text-color ctx in
   Gr.arrow 0.5pt color 6pt 5pt 1.5pt);
|)

let arr ctx dir l r =
let label-ctx = set-font-size (get-font-size ctx *' 0.75) ctx in
let grl = draw-text (0pt, 0pt) (read-inline label-ctx l) in
let grr = draw-text (0pt, 0pt) (read-inline label-ctx r) in
let ((lx0, ly0), (lx1, ly1)) = get-graphics-bbox grl in
let ((rx0, ry0), (rx1, ry1)) = get-graphics-bbox grr in
let pd = 4pt in
let (gr0, gr1) =
(match dir with
 | (Horizontal, Forwards) ->     % Right
 (shift-graphics ((0pt -' (lx0 +' lx1) *' 0.5), pd) grl,
  shift-graphics ((0pt -' (rx0 +' rx1) *' 0.5), (0pt -' pd) -' ry1) grr)
 | (Horizontal, Backwards) ->    % Left
 (shift-graphics ((0pt -' (lx0 +' lx1) *' 0.5), (0pt -' pd) -' ly1) grl,
  shift-graphics ((0pt -' (rx0 +' rx1) *' 0.5), pd) grr)
 | (Vertical, Forwards) ->       % Down
 (shift-graphics (pd -' lx0, 0pt -' (ly0 +' ly1) *' 0.5) grl,
  shift-graphics ((0pt -' pd) -' rx1, 0pt -' (ry0 +' ry1) *' 0.5) grr)
 | (Vertical, Backwards) ->      % Up
 (shift-graphics ((0pt -' pd) -' lx1, 0pt -' (ly0 +' ly1) *' 0.5) grl,
  shift-graphics (pd -' rx0, 0pt -' (ry0 +' ry1) *' 0.5) grr))
in
Arrow (arrow-config-default ctx, dir, [gr0; gr1])

let larr ctx l r = arr ctx (Horizontal, Backwards) l r

let rarr ctx l r = arr ctx (Horizontal, Forwards) l r

let uarr ctx l r = arr ctx (Vertical, Backwards) l r

let darr ctx l r = arr ctx (Vertical, Forwards) l r

let harr = rarr

let varr = darr

let draw-eq ctx from to =
let ((x0, y0), (x1, y1)) = (from, to) in
let (x, y) = (x1 -' x0, y1 -' y0) in
if Length.equal x 0pt && Length.equal y 0pt
then
[]
else
let xf = x /' 1pt in
let yf = y /' 1pt in
let r = 1.0 /. exp (0.5 *. log (xf *. xf +. yf *. yf)) in
let d = 1pt in
let dx = 0pt -' d *' (yf *. r) in
let dy = d *' (xf *. r) in
let l1 = Gr.line (x0 +' dx, y0 +' dy) (x1 +' dx, y1 +' dy) in
let l2 = Gr.line (x0 -' dx, y0 -' dy) (x1 -' dx, y1 -' dy) in
let color = get-text-color ctx in
List.map (stroke 0.5pt color) [l1; l2]

let eqarr ctx dir =
Arrow ((|
  (arrow-config-default ctx)
  with
  draw = draw-eq ctx;
|), dir, [])

let heq ctx = eqarr ctx (Horizontal, Forwards)
let veq ctx = eqarr ctx (Vertical, Forwards)

let arr2 ctx it =
let ib1 = embed-math ctx ${\Downarrow} in
let label-ctx = set-font-size (get-font-size ctx *' 0.75) ctx in
let ib2 = read-inline label-ctx it in
let gr = draw-text (0pt, 0pt) (ib1 ++ ib2) in
let ((x0, y0), (x1, y1)) = get-graphics-bbox gr in
let pdx = 6pt in
let pdy = 3pt in
let pds = (pdx, pdx, pdy, pdy) in
Object (shift-graphics (0pt -' (x1 +' x0) *' 0.5, 0pt -' 4pt) gr, pds)

let diagram ctx cellssf =
let r = (|
  emp = emp ctx;
  obj = obj ctx;
  larr = larr ctx;
  rarr = rarr ctx;
  uarr = uarr ctx;
  darr = darr ctx;
  harr = harr ctx;
  varr = varr ctx;
  heq = heq ctx;
  veq = veq ctx;
  arr2 = arr2 ctx;
|) in
let cellss = cellssf r in
let grs = draw-diagram cellss in
let ((x0, y0), (x1, y1)) = get-grs-bbox grs in
let ym = (y0 +' y1) *' 0.5 -' 4pt in
let w = x1 -' x0 in
let h = y1 -' ym in
let d = ym -' y0 in
inline-graphics w h d
(fun (px, py) ->
 (List.map (shift-graphics (px -' x0, py -' ym)) grs))

let-block ctx +diagram cellssf =
line-break true true ctx (inline-fil ++ diagram ctx cellssf ++ inline-fil)

let-inline ctx \diagram cellssf =
inline-fil ++ embed-block-breakable ctx (read-block ctx '<+diagram(cellssf);>)

let-math \diagram-m cellssf =
text-in-math MathOrd (fun ctx -> diagram ctx cellssf)

end
