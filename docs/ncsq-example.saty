@require: stdjareport
@require: itemize
@import: ../src/ncsq

let cellss1 = open NCSq in [
  [object {${A}}; arrow ?:{${f}} right; object {${B}}];
  [arrow ?*?:{${g}} down; arrow-2 ?:{${\alpha}} down;
   arrow ?:{${h}} down];
  [object {${C}}; arrow ?*?:{${k}} right; object {${D}}];
]

in

document (|
  title = {NCSq Examples};
  author = {Taichi Uemura};
|) '<
  +chapter{Basic usage}<
    +p{
      To draw a diagram, pass \code(`\NCSq.cd`); a rectangular array of cells.
      \d-code(```
    \NCSq.cd(open NCSq in [
      [object {${A}}; arrow right; object {${B}};
       arrow right; object {${C}}];
      [arrow down; empty; arrow down;
       arrow-2 down; arrow down];
      [object {${D}}; arrow right; object {${E}};
       arrow right; object {${F}}]
    ]);
```);
      \NCSq.cd(open NCSq in [
      [object {${A}}; arrow right; object {${B}};
      arrow right; object {${C}}];
      [arrow down; empty; arrow down;
      arrow-2 down; arrow down];
      [object {${D}}; arrow right; object {${E}};
      arrow right; object {${F}}]
      ]);%
      Here, \code(`empty`);, \code(`object`);, \code(`arrow`); and \code(`arrow-2`); are functions defined in \code(`NCSq`); module for building cells.
      \code(`object inline-text`); will draw an object (0-cell) with label \code(`inline-text`);.
      \code(`arrow direction`); will draw an arrow (1-cell) towards \code(`direction`);.
      Currently, \code(`direction`); can be \code(`left`);, \code(`right`);, \code(`up`);, or \code(`down`);, which are constants provided by \code(`NCSq`); module, but diagonal arrows are not supported.
      \d-code(```
    \NCSq.cd(open NCSq in [
      [object {${A}}; arrow left; object {${B}}];
    ]);
```);
      \NCSq.cd(open NCSq in [
      [object {${A}}; arrow left; object {${B}}];
      ]);
      \d-code(```
    \NCSq.cd(open NCSq in [
      [object {${A}}; arrow right; object {${B}}];
    ]);
```);
      \NCSq.cd(open NCSq in [
      [object {${A}}; arrow right; object {${B}}];
      ]);
      \d-code(```
    \NCSq.cd(open NCSq in [
      [object {${A}}];
      [arrow up];
      [object {${B}}];
    ]);
```);
      \NCSq.cd(open NCSq in [
      [object {${A}}];
      [arrow up];
      [object {${B}}];
      ]);
      \d-code(```
    \NCSq.cd(open NCSq in [
      [object {${A}}];
      [arrow down];
      [object {${B}}];
    ]);
```);
      \NCSq.cd(open NCSq in [
      [object {${A}}];
      [arrow down];
      [object {${B}}];
      ]);%
      \code(`arrow`); accepts optional arguments to make labels.
      \d-code(```
arrow ?:left-label ?:right-label direction
```);%
      \code(`left-label`); and \code(`right-label`); are labels on the left side and on the right side, respectively, facing the direction of an arrow.
      \d-code(```
    \NCSq.cd(open NCSq in [
      [object {${A}}; arrow ?:{${f}} right; object {${B}}];
    ]);
```);
      \NCSq.cd(open NCSq in [
      [object {${A}}; arrow ?:{${f}} right; object {${B}}];
      ]);
      \d-code(```
    \NCSq.cd(open NCSq in [
      [object {${A}}; arrow ?*?:{${f}} right; object {${B}}];
    ]);
```);
      \NCSq.cd(open NCSq in [
      [object {${A}}; arrow ?*?:{${f}} right; object {${B}}];
      ]);
      \code(`arrow-2 direction`); will draw a 2-arrow (2-cell) towards \code(`direction`);.
      It accepts an optional argument to make a label.
      \d-code(```
    arrow-2 ?:label direction
```);
      \d-code(```
    \NCSq.cd(open NCSq in [
      [object {${C}}; arrow ?:{${F}} right; object {${D}}];
      [arrow ?*?:{よ} down; arrow-2 ?:{${F_{1}}} right;
       arrow ?:{よ} down];
      [object {${\app{\mathbf{Fun}}{C^{\mathrm{op}}, \mathbf{Set}}}};
       arrow ?:{${F^{\ast}}} left;
       object {${\app{\mathbf{Fun}}{D^{\mathrm{op}}, \mathbf{Set}}}}];
    ]);
```);
      \NCSq.cd(open NCSq in [
      [object {${C}}; arrow ?:{${F}} right; object {${D}}];
      [arrow ?*?:{よ} down; arrow-2 ?:{${F_{1}}} right;
      arrow ?:{よ} down];
      [object {${\app{\mathbf{Fun}}{C^{\mathrm{op}}, \mathbf{Set}}}};
      arrow ?:{${F^{\ast}}} left;
      object {${\app{\mathbf{Fun}}{D^{\mathrm{op}}, \mathbf{Set}}}}];
      ]);
    }
    +p{
      Arrows stretch automatically to match long labels and large objects.
      \d-code(```
    \NCSq.cd(open NCSq in [
      [object {${A}}; arrow right; object {${B}};
       arrow ?:{the longest label I've ever seen} right; object {${C}}];
      [arrow down; empty; arrow down;
       empty; arrow down];
      [object {LARGE OBJECT}; arrow right; object {${E}};
       arrow right; object {${F}}];
    ]);
```);
      \NCSq.cd(open NCSq in [
      [object {${A}}; arrow right; object {${B}};
      arrow ?:{the longest label I've ever seen} right; object {${C}}];
      [arrow down; empty; arrow down;
      empty; arrow down];
      [object {LARGE OBJECT}; arrow right; object {${E}};
      arrow right; object {${F}}];
      ]);
      The source and the target of an arrow are automatically detected:
      the source of an arrow is the nearest object in the opposite direction of the arrow\;
      the target of an arrow is the nearest object in the direction of the arrow.
      If the source or the target of an arrow is not found, then the arrow will not be drawn.
      \d-code(```
    \NCSq.cd(open NCSq in [
      [object {${A}}; arrow right; object {${B}};
       arrow ?:{Of course, arrows sufficiently stretch} right;
       empty; empty; object {${C}}];
      [arrow down; empty; arrow down;
       empty; empty; empty; arrow down];
      [empty; empty; object {${D}};
       arrow right; object {${E}}; arrow right; object {${F}}];
      [empty; empty; arrow down;
       empty; arrow down; empty; arrow down];
      [object {${G}}; arrow right; object {${H}};
       arrow ?*?:{${f}} right; object {${I}}; empty; empty];
      [arrow down; empty; empty;
       empty; arrow down; empty; empty];
      [object {${J}};
       arrow ?*?:{even when there's another long label} right;
       empty; empty; object {${K}}; arrow right; object {${L}}];
    ]);
```);
      \NCSq.cd(open NCSq in [
      [object {${A}}; arrow right; object {${B}};
      arrow ?:{Of course, arrows sufficiently stretch} right;
      empty; empty; object {${C}}];
      [arrow down; empty; arrow down;
      empty; empty; empty; arrow down];
      [empty; empty; object {${D}};
      arrow right; object {${E}}; arrow right; object {${F}}];
      [empty; empty; arrow down;
      empty; arrow down; empty; arrow down];
      [object {${G}}; arrow right; object {${H}};
      arrow ?*?:{${f}} right; object {${I}}; empty; empty];
      [arrow down; empty; empty;
      empty; arrow down; empty; empty];
      [object {${J}};
      arrow ?*?:{even when there's another long label} right;
      empty; empty; object {${K}}; arrow right; object {${L}}];
      ]);
    }
    +p{
      \code(`NCSq.cd-m`); is suitable for drawing diagrams in math formulas.
      \d-code(```
    \eqn(${
      \paren{
        \NCSq.cd-m!(open NCSq in [
          [object {${A}}; arrow ?:{${f}} right; object {${B}};
           eqarrow right; object {${B}}];
          [eqarrow down; arrow-2 ?:{${\epsilon}} down;
           arrow ?:{${g}} down; arrow-2 ?:{${\eta}} down; eqarrow down];
          [object {${A}}; eqarrow right; object {${A}};
           arrow ?*?:{${f}} right; object {${B}}];
        ])
      } =
      \paren{
        \NCSq.cd-m!(open NCSq in [
          [object {${A}}; arrow ?:{${f}} right; object {${B}}];
          [eqarrow down; empty; eqarrow down];
          [object {${A}}; arrow ?*?:{${f}} right; object {${B}}];
        ])
      }
    });
```);
      \eqn(${
        \paren{
          \NCSq.cd-m!(open NCSq in [
            [object {${A}}; arrow ?:{${f}} right; object {${B}};
             eqarrow right; object {${B}}];
            [eqarrow down; arrow-2 ?:{${\epsilon}} down;
             arrow ?:{${g}} down; arrow-2 ?:{${\eta}} down; eqarrow down];
            [object {${A}}; eqarrow right; object {${A}};
             arrow ?*?:{${f}} right; object {${B}}];
          ])
        } =
        \paren{
          \NCSq.cd-m!(open NCSq in [
            [object {${A}}; arrow ?:{${f}} right; object {${B}}];
            [eqarrow down; empty; eqarrow down];
            [object {${A}}; arrow ?*?:{${f}} right; object {${B}}];
          ])
        }
      });
    }
    +section{\code(`\ezcd`); command}<
      +p{
        We often encounter a diagram, represented by a rectangular array ${\paren{c_{ij}}} of cells, such that
        \listing{
          * ${c_{ij}} for ${i} and ${j} odd is an object\;
          * ${c_{ij}} for ${i} odd and ${j} even is a right arrow\;
          * ${c_{ij}} for ${i} even and ${j} odd is a down arrow\;
          * ${c_{ij}} for ${i} and ${j} even is empty.
        }
        \code(`NCSq`); module provides a command \code(`\ezcd`); to provide simplified syntax for such diagrams.
        \code(`\ezcd`); receives a rectangular array of math formulas and draws a diagram.
        For example,
        \d-code(```
        \NCSq.ezcd[
          ${| A | f | B |};
          ${| g |   | h |};
          ${| C | k | D |};
        ];
```);%
        draws the following diagram.
        \NCSq.ezcd[
          ${| A | f | B |};
          ${| g |   | h |};
          ${| C | k | D |};
        ];
      }
      +p{
        A row \code(`ms`); at an odd position is thought of as a horizontal chain of arrows.
        A math formula \code(`m`); in \code(`ms`); at an odd position is converted to an object with label \code(`{${#m}}`);.
        A math formula \code(`m`); in \code(`ms`); at an even position is converted to a right arrow with label \code(`{${#m}}`);.
        The position of the label on the right arrow depends on the position of the row \code(`ms`);:
        if \code(`ms`); is in the upper half of the array, then the label is above the arrow\;
        if \code(`ms`); is in the lower half of the array, then tha label is below the arrow.
        For example, the first row in the above example is converted to
        \d-code(```
[object {${A}}; arrow ?:{${f}} right; object {${B}}]
```);%
        while the last row is converted to
        \d-code(```
[object {${C}}; arrow ?*?:{${k}} right; object {${D}}]
```);%
      }
      +p{
        A row \code(`ms`); at an even position contains vertical arrows.
        A math formula in \code(`ms`); at an even position is converted to the empty cell.
        A math formula \code(`m`); in \code(`ms`); at an odd position is converted to a down arrow with label \code(`{${#m}}`);.
        The position of the label on the down arrow depends on the position of the math formula \code(`m`);:
        if \code(`m`); is in the left half of \code(`ms`);, then the label is on the left side of the arrow\;
        if \code(`m`); is in the right half of \code(`ms`);, then the label is on the right side of the arrow.
        For example, the middle row in the above example is converted to
        \d-code(```
[arrow ?*?:{${g}} down; empty; arrow ?:{${h}} down]
```);%
      }
      +p{
        Here's a larger example.
        \d-code(```
        \NCSq.ezcd[
          ${| A | a | B | b | C | c | D |};
          ${| d |   | e |   | f |   | g |};
          ${| E | h | F | i | G | j | H |};
          ${| k |   | l |   | m |   | n |};
          ${| I | o | J | p | K | q | L |};
        ];
```);%
        \NCSq.ezcd[
          ${| A | a | B | b | C | c | D |};
          ${| d |   | e |   | f |   | g |};
          ${| E | h | F | i | G | j | H |};
          ${| k |   | l |   | m |   | n |};
          ${| I | o | J | p | K | q | L |};
        ];
      }
    >
  >
  +chapter{Changing styles}<
    +p{
      \code(`object`); accepts an optional argument to change paddings.
      \d-code(```
object ?:(pd-left, pd-right, pd-top, pd-bottom) label
```);%
      Paddings are specified by ratios to the font size.
      The default value is \code(`(pd-left, pd-right, pd-top, pd-bottom) = (0.25, 0.25, 0.25, 0.25)`);.
      \d-code(```
      \NCSq.cd(open NCSq in [
        [object ?:(0.25, 1.0, 0.25, 2.0) {${A}};
         arrow right; object {${B}}];
        [arrow down; empty; arrow down];
        [object {${C}}; arrow right;
         object ?:(2.0, 0.25, 1.0, 3.0) {${D}}];
      ]);
```);%
      \NCSq.cd(open NCSq in [
        [object ?:(0.25, 1.0, 0.25, 2.0) {${A}};
         arrow right; object {${B}}];
        [arrow down; empty; arrow down];
        [object {${C}}; arrow right;
         object ?:(2.0, 0.25, 1.0, 3.0) {${D}}];
      ]);
    }
    +p{
      \code(`arrow`); accepts the third optional argument to change the style.
      \d-code(```
arrow ?:left-label ?:right-label ?:style direction
```);%
      \code(`style`); can be \code(`solid`); (default), \code(`dashed`); or \code(`equal`);, which are constants provided by \code(`NCSq`); module.
      \d-code(```
    \NCSq.cd(open NCSq in [
      [object {${A}}; arrow ?*?*?:dashed right; object {${B}}];
    ]);
```);
      \NCSq.cd(open NCSq in [
      [object {${A}}; arrow ?*?*?:dashed right; object {${B}}];
      ]);
      \d-code(```
    \NCSq.cd(open NCSq in [
      [object {${A}}; arrow ?*?*?:equal right; object {${B}}];
    ]);
```);
      \NCSq.cd(open NCSq in [
      [object {${A}}; arrow ?*?*?:equal right; object {${B}}];
      ]);%
      \code(`NCSq`); module also provides \code(`eqarrow`); function for building an equality arrow.
      \code(`eqarrow direction`); is simply an alias to \code(`arrow ?*?*?:equal direction`);.
      \d-code(```
    \NCSq.cd(open NCSq in [
      [object {${A}}; eqarrow right; object {${B}}];
    ]);
```);
      \NCSq.cd(open NCSq in [
      [object {${A}}; eqarrow right; object {${B}}];
      ]);%
    }
    +p{
      \code(`arrow-2`); accepts the second optional argument to change paddings.
      \d-code(```
arrow-2 ?:label ?:(pd-left, pd-right, pd-top, pd-bottom) direction
```);%
      The default value is \code(`(pd-left, pd-right, pd-top, pd-bottom) = (0.5, 0.5, 0.25, 0.25)`);.
      \d-code(```
      \NCSq.cd(open NCSq in [
        [object {${A}}; arrow right; object {${B}}];
        [arrow down; arrow-2 ?*?:(0.25, 2.0, 3.0, 0.25) down;
         arrow down];
        [object {${C}}; arrow right; object {${D}}];
      ]);
```);%
      \NCSq.cd(open NCSq in [
        [object {${A}}; arrow right; object {${B}}];
        [arrow down; arrow-2 ?*?:(0.25, 2.0, 3.0, 0.25) down;
         arrow down];
        [object {${C}}; arrow right; object {${D}}];
      ]);
    }
  >
  +chapter{Utilities}<
    +p{
      \code(`NCSq`); module provides some utilities for building diagrams.
    }
    +p{
      \code(`invert-v`); inverts a diagram vertically.
      \d-code(```
% In preanble
let cellss1 = open NCSq in [
  [object {${A}}; arrow ?:{${f}} right; object {${B}}];
  [arrow ?*?:{${g}} down; arrow-2 ?:{${\alpha}} down;
   arrow ?:{${h}} down];
  [object {${C}}; arrow ?*?:{${k}} right; object {${D}}];
]
in
```);
      \d-code(```
      \NCSq.cd(cellss1);
```);
      \NCSq.cd(cellss1);
      \d-code(```
\NCSq.cd(NCSq.invert-v(cellss1));
```);
      \NCSq.cd(NCSq.invert-v(cellss1));
    }
    +p{
      \code(`transpose`); flips a diagram over its diagonal.
      \d-code(```
      \NCSq.cd(NCSq.transpose(cellss1));
```);
      \NCSq.cd(NCSq.transpose(cellss1));
    }
    +p{
      Using \code(`invert-v`); and \code(`transpose`);, one can invert a diagram horizontally, but why not preconfigure \code(`invert-h`); function.
      \d-code(```
      \NCSq.cd(NCSq.invert-h(cellss1));
```);
      \NCSq.cd(NCSq.invert-h(cellss1));
    }
  >
  +chapter{More examples}<
    +p{
      Incomplete diagrams (diagrams that contain arrows missing source or target) may be useful for building diagrams programmatically.
      \d-code(```
      \NCSq.cd(
        % Incomplete square (one face is missing)
        let square-from a f b g h = [
          ${| #a | #f | #b |};
          ${| #g |    | #h |};
        ] in
        [1; 2; 3; 4; 5]
        |> List.map (fun i -> (
          let mi = math-char MathOrd (arabic i) in
          square-from ${A_{#mi}} ${f_{#mi}} ${B_{#mi}}
          ${g_{#mi}} ${h_{#mi}}))
        |> List.concat
        |> NCSq.ezcd-convert
        |> NCSq.transpose
      );
```);%
      \NCSq.cd(
        % Incomplete square (one face is missing)
        let square-from a f b g h = [
          ${| #a | #f | #b |};
          ${| #g |    | #h |};
        ] in
        [1; 2; 3; 4; 5]
        |> List.map (fun i -> (
          let mi = math-char MathOrd (arabic i) in
          square-from ${A_{#mi}} ${f_{#mi}} ${B_{#mi}}
          ${g_{#mi}} ${h_{#mi}}))
        |> List.concat
        |> NCSq.ezcd-convert
        |> NCSq.transpose
      );
    }
    +p{
      Arrows nicely stretch vertically too, though one might rarely write such tall labels on arrows.
      \d-code(```
      \NCSq.cd(open NCSq in [
        [object {${A}}; arrow right; object {${B}}];
        [arrow ?*?:{${\frac{\frac{\frac{a}{b}}{\frac{c}{d}}}
                      {\frac{\frac{e}{f}}{\frac{g}{h}}}}} down;
         empty; arrow down];
        [empty; empty; object {${C}}];
        [empty; empty;
         arrow ?:{${\frac{\frac{\frac{i}{j}}{\frac{k}{l}}}
                    {\frac{\frac{m}{n}}{\frac{o}{p}}}}} down];
        [object {${D}}; arrow right; empty];
        [arrow down; empty; empty];
        [object {${E}}; arrow right; object {${F}}];
      ]);
```);%
      \NCSq.cd(open NCSq in [
        [object {${A}}; arrow right; object {${B}}];
        [arrow ?*?:{${\frac{\frac{\frac{a}{b}}{\frac{c}{d}}}
                      {\frac{\frac{e}{f}}{\frac{g}{h}}}}} down;
         empty; arrow down];
        [empty; empty; object {${C}}];
        [empty; empty;
         arrow ?:{${\frac{\frac{\frac{i}{j}}{\frac{k}{l}}}
                    {\frac{\frac{m}{n}}{\frac{o}{p}}}}} down];
        [object {${D}}; arrow right; empty];
        [arrow down; empty; empty];
        [object {${E}}; arrow right; object {${F}}];
      ]);
    }
  >
>
